{
  final boolean debug=logger.isDebugEnabled();
  LinkedList<LifecycleElement> initMethods=new LinkedList<LifecycleElement>();
  LinkedList<LifecycleElement> destroyMethods=new LinkedList<LifecycleElement>();
  Class<?> targetClass=clazz;
  do {
    final LinkedList<LifecycleElement> currInitMethods=new LinkedList<LifecycleElement>();
    final LinkedList<LifecycleElement> currDestroyMethods=new LinkedList<LifecycleElement>();
    ReflectionUtils.doWithLocalMethods(targetClass,new ReflectionUtils.MethodCallback(){
      @Override public void doWith(      Method method) throws IllegalArgumentException, IllegalAccessException {
        if (initAnnotationType != null) {
          if (method.getAnnotation(initAnnotationType) != null) {
            LifecycleElement element=new LifecycleElement(method);
            currInitMethods.add(element);
            if (debug) {
              logger.debug("Found init method on class [" + clazz.getName() + "]: "+ method);
            }
          }
        }
        if (destroyAnnotationType != null) {
          if (method.getAnnotation(destroyAnnotationType) != null) {
            currDestroyMethods.add(new LifecycleElement(method));
            if (debug) {
              logger.debug("Found destroy method on class [" + clazz.getName() + "]: "+ method);
            }
          }
        }
      }
    }
);
    initMethods.addAll(0,currInitMethods);
    destroyMethods.addAll(currDestroyMethods);
    targetClass=targetClass.getSuperclass();
  }
 while (targetClass != null && targetClass != Object.class);
  return new LifecycleMetadata(clazz,initMethods,destroyMethods);
}
