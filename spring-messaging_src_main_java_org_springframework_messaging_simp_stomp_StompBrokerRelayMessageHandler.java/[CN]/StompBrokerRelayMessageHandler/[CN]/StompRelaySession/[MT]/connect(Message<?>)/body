{
  Assert.notNull(connectMessage,"connectMessage is required");
  this.connectHeaders=StompHeaderAccessor.wrap(connectMessage);
  Composable<TcpConnection<Message<byte[]>,Message<byte[]>>> promise;
  if (this.reconnectInterval > 0) {
    promise=tcpClient.open(new Reconnect(){
      @Override public Tuple2<InetSocketAddress,Long> reconnect(      InetSocketAddress address,      int attempt){
        return Tuple.of(address,5000L);
      }
    }
);
  }
 else {
    promise=tcpClient.open();
  }
  promise.consume(new Consumer<TcpConnection<Message<byte[]>,Message<byte[]>>>(){
    @Override public void accept(    TcpConnection<Message<byte[]>,Message<byte[]>> connection){
      handleConnectionReady(connection,connectMessage);
    }
  }
);
  promise.when(Throwable.class,new Consumer<Throwable>(){
    @Override public void accept(    Throwable ex){
      relaySessions.remove(sessionId);
      handleTcpClientFailure("Failed to connect to message broker",ex);
    }
  }
);
}
