{
  long clientSendInterval=this.connectHeaders.getHeartbeat()[0];
  long clientReceiveInterval=this.connectHeaders.getHeartbeat()[1];
  long serverSendInterval=this.connectedHeaders.getHeartbeat()[0];
  long serverReceiveInterval=this.connectedHeaders.getHeartbeat()[1];
  if ((clientSendInterval > 0) && (serverReceiveInterval > 0)) {
    long interval=Math.max(clientSendInterval,serverReceiveInterval);
    stompConnection.connection.on().writeIdle(interval,new Runnable(){
      @Override public void run(){
        TcpConnection<Message<byte[]>,Message<byte[]>> tcpConn=stompConnection.connection;
        if (tcpConn != null) {
          tcpConn.send(MessageBuilder.withPayload(new byte[]{'\n'}).build(),new Consumer<Boolean>(){
            @Override public void accept(            Boolean result){
              if (!result) {
                handleTcpClientFailure("Failed to send heartbeat to the broker",null);
              }
            }
          }
);
        }
      }
    }
);
  }
  if (clientReceiveInterval > 0 && serverSendInterval > 0) {
    final long interval=Math.max(clientReceiveInterval,serverSendInterval) * HEARTBEAT_MULTIPLIER;
    stompConnection.connection.on().readIdle(interval,new Runnable(){
      @Override public void run(){
        String message="Broker hearbeat missed: connection idle for more than " + interval + "ms";
        if (logger.isWarnEnabled()) {
          logger.warn(message);
        }
        disconnected(message);
      }
    }
);
  }
}
