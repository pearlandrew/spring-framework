{
  TcpConnection<byte[]> conn=this.tcpConnection;
  if (!this.isStompConnected) {
    if (this.isRemoteClientSession) {
      if (logger.isDebugEnabled()) {
        logger.debug("TCP connection closed already, ignoring " + message);
      }
      return EMPTY_TASK;
    }
 else {
      throw new IllegalStateException("Cannot forward messages " + (conn != null ? "before STOMP CONNECTED. " : "while inactive. ") + "Consider subscribing to receive BrokerAvailabilityEvent's from "+ "an ApplicationListener Spring bean. Dropped "+ message);
    }
  }
  final Message<?> messageToSend=(accessor.isMutable() && accessor.isModified()) ? MessageBuilder.createMessage(message.getPayload(),accessor.getMessageHeaders()) : message;
  StompCommand command=accessor.getCommand();
  if (accessor.isHeartbeat()) {
    logger.trace("Forwarding heartbeat in session " + this.sessionId);
  }
 else   if (StompCommand.SUBSCRIBE.equals(command) && logger.isDebugEnabled()) {
    logger.debug("Forwarding SUBSCRIBE: " + messageToSend);
  }
 else   if (StompCommand.UNSUBSCRIBE.equals(command) && logger.isDebugEnabled()) {
    logger.debug("Forwarding UNSUBSCRIBE: " + messageToSend);
  }
 else   if (StompCommand.DISCONNECT.equals(command) && logger.isInfoEnabled()) {
    logger.info("Forwarding DISCONNECT: " + messageToSend);
  }
 else   if (logger.isTraceEnabled()) {
    logger.trace("Forwarding " + command + ": "+ messageToSend);
  }
  ListenableFuture<Void> future=conn.send((Message<byte[]>)messageToSend);
  future.addCallback(new ListenableFutureCallback<Void>(){
    @Override public void onSuccess(    Void result){
      if (accessor.getCommand() == StompCommand.DISCONNECT) {
        afterDisconnectSent(accessor);
      }
    }
    @Override public void onFailure(    Throwable t){
      if (tcpConnection != null) {
        handleTcpConnectionFailure("failed to forward " + messageToSend,t);
      }
 else       if (logger.isErrorEnabled()) {
        logger.error("Failed to forward " + messageToSend);
      }
    }
  }
);
  return future;
}
