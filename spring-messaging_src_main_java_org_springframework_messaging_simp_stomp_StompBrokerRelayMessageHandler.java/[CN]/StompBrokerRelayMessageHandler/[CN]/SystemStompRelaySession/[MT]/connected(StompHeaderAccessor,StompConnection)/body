{
  long brokerReceiveInterval=headers.getHeartbeat()[1];
  if ((systemHeartbeatSendInterval > 0) && (brokerReceiveInterval > 0)) {
    long interval=Math.max(systemHeartbeatSendInterval,brokerReceiveInterval);
    stompConnection.connection.on().writeIdle(interval,new Runnable(){
      @Override public void run(){
        TcpConnection<Message<byte[]>,Message<byte[]>> tcpConn=stompConnection.connection;
        if (tcpConn != null) {
          tcpConn.send(MessageBuilder.withPayload(heartbeatPayload).build(),new Consumer<Boolean>(){
            @Override public void accept(            Boolean result){
              if (!result) {
                handleTcpClientFailure("Failed to send heartbeat to the broker",null);
              }
            }
          }
);
        }
      }
    }
);
  }
  long brokerSendInterval=headers.getHeartbeat()[0];
  if (systemHeartbeatReceiveInterval > 0 && brokerSendInterval > 0) {
    final long interval=Math.max(systemHeartbeatReceiveInterval,brokerSendInterval) * HEARTBEAT_RECEIVE_MULTIPLIER;
    stompConnection.connection.on().readIdle(interval,new Runnable(){
      @Override public void run(){
        String message="Broker hearbeat missed: connection idle for more than " + interval + "ms";
        if (logger.isWarnEnabled()) {
          logger.warn(message);
        }
        disconnected(message);
      }
    }
);
  }
  super.connected(headers,stompConnection);
  publishBrokerAvailableEvent();
}
