{
  String sessionId=SimpMessageHeaderAccessor.getSessionId(message.getHeaders());
  if (!isBrokerAvailable()) {
    if (sessionId == null || SystemStompConnectionHandler.SESSION_ID.equals(sessionId)) {
      throw new MessageDeliveryException("Message broker not active. Consider subscribing to " + "receive BrokerAvailabilityEvent's from an ApplicationListener Spring bean.");
    }
    SimpMessageType messageType=SimpMessageHeaderAccessor.getMessageType(message.getHeaders());
    if (messageType.equals(SimpMessageType.CONNECT) && logger.isErrorEnabled()) {
      logger.error("Broker not active. Ignoring " + message);
    }
 else     if (logger.isDebugEnabled()) {
      logger.debug("Broker not active. Ignoring " + message);
    }
    return;
  }
  StompHeaderAccessor stompAccessor;
  StompCommand command;
  MessageHeaderAccessor accessor=MessageHeaderAccessor.getAccessor(message,MessageHeaderAccessor.class);
  if (accessor == null) {
    throw new IllegalStateException("No header accessor (not using the SimpMessagingTemplate?): " + message);
  }
 else   if (accessor instanceof StompHeaderAccessor) {
    stompAccessor=(StompHeaderAccessor)accessor;
    command=stompAccessor.getCommand();
  }
 else   if (accessor instanceof SimpMessageHeaderAccessor) {
    stompAccessor=StompHeaderAccessor.wrap(message);
    command=stompAccessor.getCommand();
    if (command == null) {
      command=stompAccessor.updateStompCommandAsClientMessage();
    }
  }
 else {
    throw new IllegalStateException("Unexpected header accessor type " + accessor.getClass() + " in "+ message);
  }
  if (sessionId == null) {
    if (!SimpMessageType.MESSAGE.equals(stompAccessor.getMessageType())) {
      logger.error("Only STOMP SEND supported from within the server side. Ignoring " + message);
      return;
    }
    sessionId=SystemStompConnectionHandler.SESSION_ID;
    stompAccessor.setSessionId(sessionId);
  }
  String destination=stompAccessor.getDestination();
  if ((command != null) && command.requiresDestination() && !checkDestinationPrefix(destination)) {
    return;
  }
  if (StompCommand.CONNECT.equals(command)) {
    if (logger.isDebugEnabled()) {
      logger.debug("STOMP CONNECT in session " + sessionId + " ("+ getConnectionCount()+ " connections).");
    }
    stompAccessor=(stompAccessor.isMutable() ? stompAccessor : StompHeaderAccessor.wrap(message));
    stompAccessor.setLogin(this.clientLogin);
    stompAccessor.setPasscode(this.clientPasscode);
    if (getVirtualHost() != null) {
      stompAccessor.setHost(getVirtualHost());
    }
    StompConnectionHandler handler=new StompConnectionHandler(sessionId,stompAccessor);
    this.connectionHandlers.put(sessionId,handler);
    this.stats.incrementConnectCount();
    this.tcpClient.connect(handler);
  }
 else   if (StompCommand.DISCONNECT.equals(command)) {
    StompConnectionHandler handler=this.connectionHandlers.get(sessionId);
    if (handler == null) {
      if (logger.isDebugEnabled()) {
        logger.debug("Ignoring DISCONNECT in session " + sessionId + ". Connection already cleaned up.");
      }
      return;
    }
    stats.incrementDisconnectCount();
    handler.forward(message,stompAccessor);
  }
 else {
    StompConnectionHandler handler=this.connectionHandlers.get(sessionId);
    if (handler == null) {
      if (logger.isDebugEnabled()) {
        logger.debug("No TCP connection for session " + sessionId + " in "+ message);
      }
      return;
    }
    handler.forward(message,stompAccessor);
  }
}
