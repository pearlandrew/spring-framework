{
  Assert.notNull(action,"Callback object must not be null");
  Session session=(enforceNewSession ? SessionFactoryUtils.getNewSession(getSessionFactory(),getEntityInterceptor()) : getSession());
  boolean existingTransaction=(!enforceNewSession && (!isAllowCreate() || SessionFactoryUtils.isSessionTransactional(session,getSessionFactory())));
  if (existingTransaction) {
    logger.debug("Found thread-bound Session for HibernateTemplate");
  }
  FlushMode previousFlushMode=null;
  try {
    previousFlushMode=applyFlushMode(session,existingTransaction);
    enableFilters(session);
    Session sessionToExpose=(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));
    Object result=action.doInHibernate(sessionToExpose);
    flushIfNecessary(session,existingTransaction);
    return result;
  }
 catch (  HibernateException ex) {
    throw convertHibernateAccessException(ex);
  }
catch (  SQLException ex) {
    throw convertJdbcAccessException(ex);
  }
catch (  RuntimeException ex) {
    throw ex;
  }
 finally {
    if (existingTransaction) {
      logger.debug("Not closing pre-bound Hibernate Session after HibernateTemplate");
      disableFilters(session);
      if (previousFlushMode != null) {
        session.setFlushMode(previousFlushMode);
      }
    }
 else {
      if (isAlwaysUseNewSession()) {
        SessionFactoryUtils.closeSession(session);
      }
 else {
        SessionFactoryUtils.closeSessionOrRegisterDeferredClose(session,getSessionFactory());
      }
    }
  }
}
