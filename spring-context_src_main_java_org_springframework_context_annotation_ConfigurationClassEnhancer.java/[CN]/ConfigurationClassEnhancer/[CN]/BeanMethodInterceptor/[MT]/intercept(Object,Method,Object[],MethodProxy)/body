{
  String beanName=BeanAnnotationHelper.determineBeanNameFor(beanMethod);
  Scope scope=AnnotationUtils.findAnnotation(beanMethod,Scope.class);
  if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {
    String scopedBeanName=ScopedProxyCreator.getTargetBeanName(beanName);
    if (this.beanFactory.isCurrentlyInCreation(scopedBeanName)) {
      beanName=scopedBeanName;
    }
  }
  if (factoryContainsBean('&' + beanName) && factoryContainsBean(beanName)) {
    Object factoryBean=this.beanFactory.getBean('&' + beanName);
    if (factoryBean instanceof ScopedProxyFactoryBean) {
    }
 else {
      return enhanceFactoryBean(factoryBean.getClass(),beanName);
    }
  }
  boolean factoryIsCaller=beanMethod.equals(SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod());
  boolean factoryAlreadyContainsSingleton=this.beanFactory.containsSingleton(beanName);
  if (factoryIsCaller && !factoryAlreadyContainsSingleton) {
    if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {
      logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " + "assignable to Spring's BeanFactoryPostProcessor interface. This will " + "result in a failure to process annotations such as @Autowired, "+ "@Resource and @PostConstruct within the method's declaring "+ "@Configuration class. Add the 'static' modifier to this method to avoid "+ "these container lifecycle issues; see @Bean Javadoc for complete details",beanMethod.getDeclaringClass().getSimpleName(),beanMethod.getName()));
    }
    return cglibMethodProxy.invokeSuper(enhancedConfigInstance,beanMethodArgs);
  }
 else {
    boolean alreadyInCreation=this.beanFactory.isCurrentlyInCreation(beanName);
    try {
      if (alreadyInCreation) {
        this.beanFactory.setCurrentlyInCreation(beanName,false);
      }
      return this.beanFactory.getBean(beanName);
    }
  finally {
      if (alreadyInCreation) {
        this.beanFactory.setCurrentlyInCreation(beanName,true);
      }
    }
  }
}
