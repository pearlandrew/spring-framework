{
  ConfigurableBeanFactory beanFactory=getBeanFactory(enhancedConfigInstance);
  String beanName=BeanAnnotationHelper.determineBeanNameFor(beanMethod);
  Scope scope=AnnotationUtils.findAnnotation(beanMethod,Scope.class);
  if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {
    String scopedBeanName=ScopedProxyCreator.getTargetBeanName(beanName);
    if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {
      beanName=scopedBeanName;
    }
  }
  if (factoryContainsBean(beanFactory,BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanFactory,beanName)) {
    Object factoryBean=beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);
    if (factoryBean instanceof ScopedProxyFactoryBean) {
    }
 else {
      return enhanceFactoryBean(factoryBean.getClass(),beanFactory,beanName);
    }
  }
  if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
    if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {
      logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " + "assignable to Spring's BeanFactoryPostProcessor interface. This will " + "result in a failure to process annotations such as @Autowired, "+ "@Resource and @PostConstruct within the method's declaring "+ "@Configuration class. Add the 'static' modifier to this method to avoid "+ "these container lifecycle issues; see @Bean javadoc for complete details",beanMethod.getDeclaringClass().getSimpleName(),beanMethod.getName()));
    }
    return cglibMethodProxy.invokeSuper(enhancedConfigInstance,beanMethodArgs);
  }
 else {
    boolean alreadyInCreation=beanFactory.isCurrentlyInCreation(beanName);
    try {
      if (alreadyInCreation) {
        beanFactory.setCurrentlyInCreation(beanName,false);
      }
      return (!ObjectUtils.isEmpty(beanMethodArgs) ? beanFactory.getBean(beanName,beanMethodArgs) : beanFactory.getBean(beanName));
    }
  finally {
      if (alreadyInCreation) {
        beanFactory.setCurrentlyInCreation(beanName,true);
      }
    }
  }
}
