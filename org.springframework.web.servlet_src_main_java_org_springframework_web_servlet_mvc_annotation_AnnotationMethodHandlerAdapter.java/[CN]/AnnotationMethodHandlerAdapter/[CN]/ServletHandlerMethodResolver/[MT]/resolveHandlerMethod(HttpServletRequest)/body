{
  String lookupPath=urlPathHelper.getLookupPathForRequest(request);
  Comparator<String> pathComparator=pathMatcher.getPatternComparator(lookupPath);
  Map<RequestMappingInfo,Method> targetHandlerMethods=new LinkedHashMap<RequestMappingInfo,Method>();
  Set<String> allowedMethods=new LinkedHashSet<String>(7);
  String resolvedMethodName=null;
  for (  Method handlerMethod : getHandlerMethods()) {
    RequestMappingInfo mappingInfo=createRequestMappingInfo(handlerMethod);
    boolean match=false;
    if (mappingInfo.hasPatterns()) {
      List<String> matchingPatterns=new ArrayList<String>(mappingInfo.patterns.length);
      for (      String pattern : mappingInfo.patterns) {
        if (!hasTypeLevelMapping() && !pattern.startsWith("/")) {
          pattern="/" + pattern;
        }
        String combinedPattern=getCombinedPattern(pattern,lookupPath,request);
        if (combinedPattern != null) {
          if (mappingInfo.matches(request)) {
            match=true;
            matchingPatterns.add(combinedPattern);
          }
 else {
            if (!mappingInfo.matchesRequestMethod(request)) {
              allowedMethods.addAll(mappingInfo.methodNames());
            }
            break;
          }
        }
      }
      Collections.sort(matchingPatterns,pathComparator);
      mappingInfo.matchedPatterns=matchingPatterns;
    }
 else {
      match=mappingInfo.matches(request);
      if (match && mappingInfo.methods.length == 0 && mappingInfo.params.length == 0 && resolvedMethodName != null && !resolvedMethodName.equals(handlerMethod.getName())) {
        match=false;
      }
 else {
        if (!mappingInfo.matchesRequestMethod(request)) {
          allowedMethods.addAll(mappingInfo.methodNames());
        }
      }
    }
    if (match) {
      Method oldMappedMethod=targetHandlerMethods.put(mappingInfo,handlerMethod);
      if (oldMappedMethod != null && oldMappedMethod != handlerMethod) {
        if (methodNameResolver != null && mappingInfo.patterns.length == 0) {
          if (!oldMappedMethod.getName().equals(handlerMethod.getName())) {
            if (resolvedMethodName == null) {
              resolvedMethodName=methodNameResolver.getHandlerMethodName(request);
            }
            if (!resolvedMethodName.equals(oldMappedMethod.getName())) {
              oldMappedMethod=null;
            }
            if (!resolvedMethodName.equals(handlerMethod.getName())) {
              if (oldMappedMethod != null) {
                targetHandlerMethods.put(mappingInfo,oldMappedMethod);
                oldMappedMethod=null;
              }
 else {
                targetHandlerMethods.remove(mappingInfo);
              }
            }
          }
        }
        if (oldMappedMethod != null) {
          throw new IllegalStateException("Ambiguous handler methods mapped for HTTP path '" + lookupPath + "': {"+ oldMappedMethod+ ", "+ handlerMethod+ "}. If you intend to handle the same path in multiple methods, then factor "+ "them out into a dedicated handler class with that path mapped at the type level!");
        }
      }
    }
  }
  if (!targetHandlerMethods.isEmpty()) {
    List<RequestMappingInfo> matches=new ArrayList<RequestMappingInfo>(targetHandlerMethods.keySet());
    RequestMappingInfoComparator requestMappingInfoComparator=new RequestMappingInfoComparator(pathComparator,request);
    Collections.sort(matches,requestMappingInfoComparator);
    RequestMappingInfo bestMappingMatch=matches.get(0);
    String bestMatchedPath=bestMappingMatch.bestMatchedPattern();
    if (bestMatchedPath != null) {
      extractHandlerMethodUriTemplates(bestMatchedPath,lookupPath,request);
    }
    return targetHandlerMethods.get(bestMappingMatch);
  }
 else {
    if (!allowedMethods.isEmpty()) {
      throw new HttpRequestMethodNotSupportedException(request.getMethod(),StringUtils.toStringArray(allowedMethods));
    }
    throw new NoSuchRequestHandlingMethodException(lookupPath,request.getMethod(),request.getParameterMap());
  }
}
