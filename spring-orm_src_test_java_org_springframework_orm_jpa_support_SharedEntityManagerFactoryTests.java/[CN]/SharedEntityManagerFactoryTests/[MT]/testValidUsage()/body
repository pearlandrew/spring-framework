{
  Object o=new Object();
  MockControl emMc=MockControl.createControl(EntityManager.class);
  EntityManager mockEm=(EntityManager)emMc.getMock();
  mockEm.contains(o);
  emMc.setReturnValue(false,1);
  emMc.expectAndReturn(mockEm.isOpen(),true);
  mockEm.close();
  emMc.setVoidCallable(1);
  emMc.replay();
  MockControl emfMc=MockControl.createControl(EntityManagerFactory.class);
  EntityManagerFactory mockEmf=(EntityManagerFactory)emfMc.getMock();
  mockEmf.createEntityManager();
  emfMc.setReturnValue(mockEm,1);
  emfMc.replay();
  SharedEntityManagerBean proxyFactoryBean=new SharedEntityManagerBean();
  proxyFactoryBean.setEntityManagerFactory(mockEmf);
  proxyFactoryBean.afterPropertiesSet();
  assertTrue(EntityManager.class.isAssignableFrom(proxyFactoryBean.getObjectType()));
  assertTrue(proxyFactoryBean.isSingleton());
  EntityManager proxy=(EntityManager)proxyFactoryBean.getObject();
  assertSame(proxy,proxyFactoryBean.getObject());
  assertFalse(proxy.contains(o));
  assertTrue(proxy instanceof EntityManagerProxy);
  EntityManagerProxy emProxy=(EntityManagerProxy)proxy;
  try {
    emProxy.getTargetEntityManager();
    fail("Should have thrown IllegalStateException outside of transaction");
  }
 catch (  IllegalStateException ex) {
  }
  TransactionSynchronizationManager.bindResource(mockEmf,new EntityManagerHolder(mockEm));
  try {
    assertSame(mockEm,emProxy.getTargetEntityManager());
  }
  finally {
    TransactionSynchronizationManager.unbindResource(mockEmf);
  }
  emfMc.verify();
  emMc.verify();
  assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty());
}
