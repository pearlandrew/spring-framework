{
  CachedMethodExecutor executorToCheck=this.cachedExecutor;
  if (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {
    throw new IllegalStateException("No applicable cached executor found: " + executorToCheck);
  }
  ReflectiveMethodExecutor methodExecutor=(ReflectiveMethodExecutor)executorToCheck.get();
  Method method=methodExecutor.getMethod();
  boolean isStaticMethod=Modifier.isStatic(method.getModifiers());
  String descriptor=cf.lastDescriptor();
  if (descriptor == null && !isStaticMethod) {
    cf.loadTarget(mv);
  }
  if (CodeFlow.isPrimitive(descriptor)) {
    CodeFlow.insertBoxIfNecessary(mv,descriptor.charAt(0));
  }
  boolean itf=method.getDeclaringClass().isInterface();
  String methodDeclaringClassSlashedDescriptor=null;
  if (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {
    methodDeclaringClassSlashedDescriptor=method.getDeclaringClass().getName().replace('.','/');
  }
 else {
    methodDeclaringClassSlashedDescriptor=methodExecutor.getPublicDeclaringClass().getName().replace('.','/');
  }
  if (!isStaticMethod) {
    if (descriptor == null || !descriptor.substring(1).equals(methodDeclaringClassSlashedDescriptor)) {
      CodeFlow.insertCheckCast(mv,"L" + methodDeclaringClassSlashedDescriptor);
    }
  }
  CodeFlow.generateCodeForArguments(mv,cf,method,children);
  mv.visitMethodInsn(isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL,methodDeclaringClassSlashedDescriptor,method.getName(),CodeFlow.createSignatureDescriptor(method),itf);
  cf.pushDescriptor(this.exitTypeDescriptor);
}
