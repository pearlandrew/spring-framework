{
  CachedMethodExecutor executorToCheck=this.cachedExecutor;
  if (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {
    throw new IllegalStateException("No applicable cached executor found: " + executorToCheck);
  }
  Method method=((ReflectiveMethodExecutor)executorToCheck.get()).getMethod();
  boolean isStaticMethod=Modifier.isStatic(method.getModifiers());
  String descriptor=codeflow.lastDescriptor();
  if (descriptor == null && !isStaticMethod) {
    codeflow.loadTarget(mv);
  }
  boolean itf=method.getDeclaringClass().isInterface();
  String methodDeclaringClassSlashedDescriptor=method.getDeclaringClass().getName().replace('.','/');
  if (!isStaticMethod) {
    if (descriptor == null || !descriptor.equals(methodDeclaringClassSlashedDescriptor)) {
      mv.visitTypeInsn(CHECKCAST,methodDeclaringClassSlashedDescriptor);
    }
  }
  String[] paramDescriptors=CodeFlow.toParamDescriptors(method);
  for (int i=0; i < this.children.length; i++) {
    SpelNodeImpl child=this.children[i];
    codeflow.enterCompilationScope();
    child.generateCode(mv,codeflow);
    if (CodeFlow.isPrimitive(codeflow.lastDescriptor()) && paramDescriptors[i].charAt(0) == 'L') {
      CodeFlow.insertBoxIfNecessary(mv,codeflow.lastDescriptor().charAt(0));
    }
 else     if (!codeflow.lastDescriptor().equals(paramDescriptors[i])) {
      CodeFlow.insertCheckCast(mv,paramDescriptors[i]);
    }
    codeflow.exitCompilationScope();
  }
  mv.visitMethodInsn(isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL,methodDeclaringClassSlashedDescriptor,method.getName(),CodeFlow.createSignatureDescriptor(method),itf);
  codeflow.pushDescriptor(this.exitTypeDescriptor);
}
