{
  StompHeaderAccessor headers=StompHeaderAccessor.wrap(message);
  headers.setStompCommandIfNotSet(StompCommand.MESSAGE);
  if (StompCommand.CONNECTED.equals(headers.getStompCommand())) {
    return;
  }
  String sessionId=headers.getSessionId();
  if (sessionId == null) {
    logger.error("No \"sessionId\" header in message: " + message);
  }
  SessionInfo sessionInfo=this.sessionInfos.get(sessionId);
  WebSocketSession session=sessionInfo.getWebSocketSession();
  if (session == null) {
    logger.error("Session not found: " + message);
  }
  if (headers.getSubscriptionId() == null) {
    String destination=headers.getDestination();
    Set<String> subs=sessionInfo.getSubscriptionsForDestination(destination);
    if (subs != null) {
      headers.setSubscriptionId(subs.iterator().next());
    }
 else {
      logger.error("No subscription id: " + message);
      return;
    }
  }
  byte[] payload;
  try {
    MediaType contentType=headers.getContentType();
    payload=payloadConverter.convertToPayload(message.getPayload(),contentType);
  }
 catch (  Throwable t) {
    logger.error("Failed to send " + message,t);
    return;
  }
  try {
    @SuppressWarnings("unchecked") M byteMessage=(M)MessageBuilder.withPayload(payload).copyHeaders(headers.toHeaders()).build();
    byte[] bytes=getStompMessageConverter().fromMessage(byteMessage);
    session.sendMessage(new TextMessage(new String(bytes,Charset.forName("UTF-8"))));
  }
 catch (  Throwable t) {
    sendErrorMessage(session,t);
  }
 finally {
    if (StompCommand.ERROR.equals(headers.getStompCommand())) {
      try {
        session.close(CloseStatus.PROTOCOL_ERROR);
      }
 catch (      IOException e) {
      }
    }
  }
}
