{
synchronized (this.sessions) {
    if (this.sessionCleanupTask != null) {
      return;
    }
    this.sessionCleanupTask=getTaskScheduler().scheduleAtFixedRate(new Runnable(){
      @Override public void run(){
        try {
          int count=sessions.size();
          if (logger.isTraceEnabled() && (count != 0)) {
            logger.trace("Checking " + count + " session(s) for timeouts ["+ getName()+ "]");
          }
          for (          SockJsSession session : sessions.values()) {
            if (session.getTimeSinceLastActive() > getDisconnectDelay()) {
              if (logger.isTraceEnabled()) {
                logger.trace("Removing " + session + " for ["+ getName()+ "]");
              }
              session.close();
              sessions.remove(session.getId());
            }
          }
          if (logger.isTraceEnabled() && count > 0) {
            logger.trace(sessions.size() + " remaining session(s) [" + getName()+ "]");
          }
        }
 catch (        Throwable ex) {
          if (logger.isErrorEnabled()) {
            logger.error("Failed to complete session timeout checks for [" + getName() + "]",ex);
          }
        }
      }
    }
,getDisconnectDelay());
  }
}
