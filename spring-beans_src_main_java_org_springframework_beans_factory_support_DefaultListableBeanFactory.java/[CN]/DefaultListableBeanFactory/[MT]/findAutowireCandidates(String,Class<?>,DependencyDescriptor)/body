{
  String[] candidateNames=BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this,requiredType,true,descriptor.isEager());
  Map<String,Object> result=new LinkedHashMap<String,Object>(candidateNames.length);
  for (  Class<?> autowiringType : this.resolvableDependencies.keySet()) {
    if (autowiringType.isAssignableFrom(requiredType)) {
      Object autowiringValue=this.resolvableDependencies.get(autowiringType);
      autowiringValue=AutowireUtils.resolveAutowiringValue(autowiringValue,requiredType);
      if (requiredType.isInstance(autowiringValue)) {
        result.put(ObjectUtils.identityToString(autowiringValue),autowiringValue);
        break;
      }
    }
  }
  for (  String candidateName : candidateNames) {
    if (!isSelfReference(beanName,candidateName) && isAutowireCandidate(candidateName,descriptor)) {
      result.put(candidateName,descriptor.resolveCandidate(candidateName,this));
    }
  }
  if (result.isEmpty() && !indicatesMultipleBeans(requiredType)) {
    DependencyDescriptor fallbackDescriptor=descriptor.forFallbackMatch();
    for (    String candidateName : candidateNames) {
      if (!isSelfReference(beanName,candidateName) && isAutowireCandidate(candidateName,fallbackDescriptor)) {
        result.put(candidateName,descriptor.resolveCandidate(candidateName,this));
      }
    }
    if (result.isEmpty()) {
      for (      String candidateName : candidateNames) {
        if (isSelfReference(beanName,candidateName) && isAutowireCandidate(candidateName,fallbackDescriptor)) {
          result.put(candidateName,descriptor.resolveCandidate(candidateName,this));
        }
      }
    }
  }
  return result;
}
