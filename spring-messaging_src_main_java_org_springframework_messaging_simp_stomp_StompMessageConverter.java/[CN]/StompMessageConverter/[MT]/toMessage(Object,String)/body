{
  byte[] byteContent=null;
  if (stompContent instanceof String) {
    byteContent=((String)stompContent).getBytes(STOMP_CHARSET);
  }
 else   if (stompContent instanceof byte[]) {
    byteContent=(byte[])stompContent;
  }
 else {
    throw new IllegalArgumentException("stompContent is neither String nor byte[]: " + stompContent.getClass());
  }
  int totalLength=byteContent.length;
  if (byteContent[totalLength - 1] == 0) {
    totalLength--;
  }
  int payloadIndex=findIndexOfPayload(byteContent);
  if (payloadIndex == 0) {
    throw new StompConversionException("No command found");
  }
  String headerContent=new String(byteContent,0,payloadIndex,STOMP_CHARSET);
  Parser parser=new Parser(headerContent);
  StompCommand command=StompCommand.valueOf(parser.nextToken(LF).trim());
  Assert.notNull(command,"No command found");
  MultiValueMap<String,String> headers=new LinkedMultiValueMap<String,String>();
  while (parser.hasNext()) {
    String header=parser.nextToken(COLON);
    if (header != null) {
      if (parser.hasNext()) {
        String value=parser.nextToken(LF);
        headers.add(header,value);
      }
 else {
        throw new StompConversionException("Parse exception for " + headerContent);
      }
    }
  }
  StompHeaderAccessor stompHeaders=StompHeaderAccessor.create(command,headers);
  stompHeaders.setSessionId(sessionId);
  byte[] payload=new byte[totalLength - payloadIndex];
  System.arraycopy(byteContent,payloadIndex,payload,0,totalLength - payloadIndex);
  return MessageBuilder.withPayload(payload).copyHeaders(stompHeaders.toMap()).build();
}
