{
  UserTransaction ut=mock(UserTransaction.class);
  final SessionFactory sf=mock(SessionFactory.class);
  final Session session=mock(Session.class);
  Query query=mock(Query.class);
  if (status == Status.STATUS_NO_TRANSACTION) {
    given(ut.getStatus()).willReturn(status,Status.STATUS_ACTIVE);
  }
 else {
    given(ut.getStatus()).willReturn(status);
  }
  final List list=new ArrayList();
  list.add("test");
  given(sf.openSession()).willReturn(session);
  given(session.getSessionFactory()).willReturn(sf);
  given(session.isOpen()).willReturn(true);
  given(session.createQuery("some query string")).willReturn(query);
  given(query.list()).willReturn(list);
  given(session.getFlushMode()).willReturn(FlushMode.AUTO);
  JtaTransactionManager ptm=new JtaTransactionManager(ut);
  TransactionTemplate tt=new TransactionTemplate(ptm);
  tt.setReadOnly(readOnly);
  assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
  assertTrue("Hasn't thread session",!TransactionSynchronizationManager.hasResource(sf));
  Object result=tt.execute(new TransactionCallback(){
    @Override public Object doInTransaction(    TransactionStatus status){
      try {
        assertTrue("JTA synchronizations active",TransactionSynchronizationManager.isSynchronizationActive());
        assertTrue("Hasn't thread session",!TransactionSynchronizationManager.hasResource(sf));
        HibernateTemplate ht=new HibernateTemplate(sf);
        ht.setExposeNativeSession(true);
        ht.executeFind(new HibernateCallback(){
          @Override public Object doInHibernate(          org.hibernate.Session sess){
            assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
            assertEquals(session,sess);
            return null;
          }
        }
);
        ht=new HibernateTemplate(sf);
        List htl=ht.executeFind(new HibernateCallback(){
          @Override public Object doInHibernate(          org.hibernate.Session sess){
            assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
            return sess.createQuery("some query string").list();
          }
        }
);
        assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
        return htl;
      }
 catch (      Error err) {
        err.printStackTrace();
        throw err;
      }
    }
  }
);
  assertTrue("Correct result list",result == list);
  assertTrue("Hasn't thread session",!TransactionSynchronizationManager.hasResource(sf));
  assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
  if (status == Status.STATUS_NO_TRANSACTION) {
    InOrder ordered=inOrder(ut);
    ordered.verify(ut).begin();
    ordered.verify(ut).commit();
  }
  if (readOnly) {
    verify(session).setFlushMode(FlushMode.MANUAL);
  }
 else {
    verify(session).flush();
  }
  verify(session).close();
}
