{
  MockControl utControl=MockControl.createControl(UserTransaction.class);
  UserTransaction ut=(UserTransaction)utControl.getMock();
  ut.getStatus();
  utControl.setReturnValue(Status.STATUS_NO_TRANSACTION,1);
  ut.begin();
  utControl.setVoidCallable(1);
  ut.getStatus();
  utControl.setReturnValue(Status.STATUS_ACTIVE,1);
  ut.rollback();
  utControl.setVoidCallable(1);
  utControl.replay();
  MockControl sfControl=MockControl.createControl(SessionFactory.class);
  final SessionFactory sf=(SessionFactory)sfControl.getMock();
  final MockControl sessionControl=MockControl.createControl(Session.class);
  final Session session=(Session)sessionControl.getMock();
  sf.openSession();
  sfControl.setReturnValue(session,1);
  session.getSessionFactory();
  sessionControl.setReturnValue(sf,1);
  session.isOpen();
  sessionControl.setReturnValue(true,1);
  sfControl.replay();
  sessionControl.replay();
  JtaTransactionManager ptm=new JtaTransactionManager(ut);
  TransactionTemplate tt=new TransactionTemplate(ptm);
  final List l=new ArrayList();
  l.add("test");
  final HibernateException flushEx=new HibernateException("flush failure");
  assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
  assertTrue("Hasn't thread session",!TransactionSynchronizationManager.hasResource(sf));
  try {
    tt.execute(new TransactionCallback(){
      public Object doInTransaction(      TransactionStatus status){
        try {
          assertTrue("JTA synchronizations active",TransactionSynchronizationManager.isSynchronizationActive());
          assertTrue("Hasn't thread session",!TransactionSynchronizationManager.hasResource(sf));
          HibernateTemplate ht=new HibernateTemplate(sf);
          ht.setExposeNativeSession(true);
          List htl=ht.executeFind(new HibernateCallback(){
            public Object doInHibernate(            org.hibernate.Session sess){
              assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
              assertEquals(session,sess);
              return l;
            }
          }
);
          ht=new HibernateTemplate(sf);
          ht.setExposeNativeSession(true);
          htl=ht.executeFind(new HibernateCallback(){
            public Object doInHibernate(            org.hibernate.Session sess){
              assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
              assertEquals(session,sess);
              return l;
            }
          }
);
          assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
          sessionControl.verify();
          sessionControl.reset();
          session.getFlushMode();
          sessionControl.setReturnValue(FlushMode.AUTO,1);
          session.flush();
          sessionControl.setThrowable(flushEx);
          session.close();
          sessionControl.setReturnValue(null,1);
          sessionControl.replay();
          return htl;
        }
 catch (        Error err) {
          err.printStackTrace();
          throw err;
        }
      }
    }
);
  }
 catch (  DataAccessException ex) {
    assertTrue(flushEx == ex.getCause());
  }
  assertTrue("Hasn't thread session",!TransactionSynchronizationManager.hasResource(sf));
  assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
  utControl.verify();
  sfControl.verify();
  sessionControl.verify();
}
