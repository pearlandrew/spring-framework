{
  UserTransaction ut=mock(UserTransaction.class);
  given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,Status.STATUS_ACTIVE,Status.STATUS_ACTIVE);
  TransactionManager tm=mock(TransactionManager.class);
  if (jtaTm) {
    MockJtaTransaction transaction=new MockJtaTransaction();
    given(tm.getTransaction()).willReturn(transaction);
  }
  final SessionFactoryImplementor sf=mock(SessionFactoryImplementor.class);
  final ExtendedSession session=mock(ExtendedSession.class);
  given(sf.getTransactionManager()).willReturn(jtaTm ? tm : null);
  given(session.isOpen()).willReturn(true);
  given(session.getFlushMode()).willReturn(flushNever ? FlushMode.MANUAL : FlushMode.AUTO);
  TransactionSynchronizationManager.bindResource(sf,new SessionHolder(session));
  try {
    JtaTransactionManager ptm=new JtaTransactionManager(ut);
    TransactionTemplate tt=new TransactionTemplate(ptm);
    tt.setReadOnly(readOnly);
    final List l=new ArrayList();
    l.add("test");
    assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
    assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
    Object result=tt.execute(new TransactionCallback(){
      @Override public Object doInTransaction(      TransactionStatus status){
        try {
          assertTrue("JTA synchronizations active",TransactionSynchronizationManager.isSynchronizationActive());
          assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
          HibernateTemplate ht=new HibernateTemplate(sf);
          ht.setExposeNativeSession(true);
          List htl=null;
          for (int i=0; i < 5; i++) {
            htl=ht.executeFind(new HibernateCallback(){
              @Override public Object doInHibernate(              org.hibernate.Session sess){
                assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
                assertEquals(session,sess);
                return l;
              }
            }
);
            assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
          }
          return htl;
        }
 catch (        Error err) {
          err.printStackTrace();
          throw err;
        }
      }
    }
);
    assertTrue("Correct result list",result == l);
    assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
    assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
  }
  finally {
    TransactionSynchronizationManager.unbindResource(sf);
  }
  verify(ut).begin();
  verify(ut).commit();
  if (flushNever) {
    if (!readOnly) {
      InOrder ordered=inOrder(session);
      ordered.verify(session).setFlushMode(FlushMode.AUTO);
      ordered.verify(session).setFlushMode(FlushMode.MANUAL);
    }
  }
  if (!flushNever && !readOnly) {
    verify(session).flush();
  }
  verify(session).afterTransactionCompletion(true,null);
  verify(session).disconnect();
}
