{
  MockControl utControl=MockControl.createControl(UserTransaction.class);
  UserTransaction ut=(UserTransaction)utControl.getMock();
  ut.getStatus();
  utControl.setReturnValue(Status.STATUS_NO_TRANSACTION,1);
  ut.getStatus();
  utControl.setReturnValue(Status.STATUS_ACTIVE,2);
  ut.getStatus();
  utControl.setReturnValue(Status.STATUS_MARKED_ROLLBACK,2);
  ut.begin();
  utControl.setVoidCallable(1);
  ut.setRollbackOnly();
  utControl.setVoidCallable(1);
  RollbackException rex=new RollbackException();
  ut.commit();
  utControl.setThrowable(rex,1);
  utControl.replay();
  MockControl sfControl=MockControl.createControl(SessionFactory.class);
  final SessionFactory sf=(SessionFactory)sfControl.getMock();
  final MockControl sessionControl=MockControl.createControl(Session.class);
  final Session session=(Session)sessionControl.getMock();
  session.getSessionFactory();
  sessionControl.setReturnValue(sf,1);
  session.isOpen();
  sessionControl.setReturnValue(true,5);
  session.getFlushMode();
  sessionControl.setReturnValue(FlushMode.AUTO,1);
  sfControl.replay();
  sessionControl.replay();
  TransactionSynchronizationManager.bindResource(sf,new SessionHolder(session));
  try {
    JtaTransactionManager ptm=new JtaTransactionManager(ut);
    final TransactionTemplate tt=new TransactionTemplate(ptm);
    assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
    assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
    tt.execute(new TransactionCallbackWithoutResult(){
      public void doInTransactionWithoutResult(      TransactionStatus status){
        tt.execute(new TransactionCallbackWithoutResult(){
          public void doInTransactionWithoutResult(          TransactionStatus status){
            status.setRollbackOnly();
            try {
              assertTrue("JTA synchronizations active",TransactionSynchronizationManager.isSynchronizationActive());
              assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
              HibernateTemplate ht=new HibernateTemplate(sf);
              ht.setExposeNativeSession(true);
              for (int i=0; i < 5; i++) {
                ht.execute(new HibernateCallback(){
                  public Object doInHibernate(                  org.hibernate.Session sess){
                    assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
                    assertEquals(session,sess);
                    return null;
                  }
                }
);
                assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
              }
              sessionControl.verify();
              sessionControl.reset();
              session.getFlushMode();
              sessionControl.setReturnValue(FlushMode.AUTO,1);
              session.flush();
              sessionControl.setVoidCallable(1);
              session.disconnect();
              sessionControl.setReturnValue(null,1);
              session.clear();
              sessionControl.setVoidCallable(1);
              sessionControl.replay();
            }
 catch (            Error err) {
              err.printStackTrace();
              throw err;
            }
          }
        }
);
      }
    }
);
    fail("Should have thrown UnexpectedRollbackException");
  }
 catch (  UnexpectedRollbackException ex) {
    assertEquals(rex,ex.getCause());
  }
 finally {
    TransactionSynchronizationManager.unbindResource(sf);
  }
  utControl.verify();
  sfControl.verify();
  sessionControl.verify();
}
