{
  UserTransaction ut=mock(UserTransaction.class);
  given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,Status.STATUS_ACTIVE,Status.STATUS_ACTIVE,Status.STATUS_MARKED_ROLLBACK,Status.STATUS_MARKED_ROLLBACK);
  RollbackException rex=new RollbackException();
  willThrow(rex).given(ut).commit();
  final SessionFactory sf=mock(SessionFactory.class);
  final Session session=mock(Session.class);
  given(session.getSessionFactory()).willReturn(sf);
  given(session.isOpen()).willReturn(true);
  given(session.getFlushMode()).willReturn(FlushMode.AUTO);
  TransactionSynchronizationManager.bindResource(sf,new SessionHolder(session));
  try {
    JtaTransactionManager ptm=new JtaTransactionManager(ut);
    final TransactionTemplate tt=new TransactionTemplate(ptm);
    assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
    assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
    tt.execute(new TransactionCallbackWithoutResult(){
      @Override public void doInTransactionWithoutResult(      TransactionStatus status){
        tt.execute(new TransactionCallbackWithoutResult(){
          @Override public void doInTransactionWithoutResult(          TransactionStatus status){
            status.setRollbackOnly();
            try {
              assertTrue("JTA synchronizations active",TransactionSynchronizationManager.isSynchronizationActive());
              assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
              HibernateTemplate ht=new HibernateTemplate(sf);
              ht.setExposeNativeSession(true);
              for (int i=0; i < 5; i++) {
                ht.execute(new HibernateCallback(){
                  @Override public Object doInHibernate(                  org.hibernate.Session sess){
                    assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
                    assertEquals(session,sess);
                    return null;
                  }
                }
);
                assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
              }
            }
 catch (            Error err) {
              err.printStackTrace();
              throw err;
            }
          }
        }
);
      }
    }
);
    fail("Should have thrown UnexpectedRollbackException");
  }
 catch (  UnexpectedRollbackException ex) {
    assertEquals(rex,ex.getCause());
  }
 finally {
    TransactionSynchronizationManager.unbindResource(sf);
  }
  verify(ut).begin();
  verify(ut).setRollbackOnly();
  verify(session).flush();
  verify(session).disconnect();
  verify(session).clear();
}
