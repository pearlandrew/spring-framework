{
  HttpServletRequest processedRequest=request;
  HandlerExecutionChain mappedHandler=null;
  boolean multipartRequestParsed=false;
  WebAsyncManager asyncManager=WebAsyncUtils.getAsyncManager(request);
  try {
    ModelAndView mv=null;
    Exception dispatchException=null;
    try {
      processedRequest=checkMultipart(request);
      multipartRequestParsed=processedRequest != request;
      mappedHandler=getHandler(processedRequest);
      if (mappedHandler == null || mappedHandler.getHandler() == null) {
        noHandlerFound(processedRequest,response);
        return;
      }
      HandlerAdapter ha=getHandlerAdapter(mappedHandler.getHandler());
      String method=request.getMethod();
      boolean isGet="GET".equals(method);
      if (isGet || "HEAD".equals(method)) {
        long lastModified=ha.getLastModified(request,mappedHandler.getHandler());
        if (logger.isDebugEnabled()) {
          String requestUri=urlPathHelper.getRequestUri(request);
          logger.debug("Last-Modified value for [" + requestUri + "] is: "+ lastModified);
        }
        if (new ServletWebRequest(request,response).checkNotModified(lastModified) && isGet) {
          return;
        }
      }
      if (!mappedHandler.applyPreHandle(processedRequest,response)) {
        return;
      }
      try {
        mv=ha.handle(processedRequest,response,mappedHandler.getHandler());
      }
  finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
          return;
        }
      }
      applyDefaultViewName(request,mv);
      mappedHandler.applyPostHandle(processedRequest,response,mv);
    }
 catch (    Exception ex) {
      dispatchException=ex;
    }
    processDispatchResult(processedRequest,response,mappedHandler,mv,dispatchException);
  }
 catch (  Exception ex) {
    triggerAfterCompletion(processedRequest,response,mappedHandler,ex);
  }
catch (  Error err) {
    triggerAfterCompletionWithError(processedRequest,response,mappedHandler,err);
  }
 finally {
    if (asyncManager.isConcurrentHandlingStarted()) {
      mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest,response);
      return;
    }
    if (multipartRequestParsed) {
      cleanupMultipart(processedRequest);
    }
  }
}
