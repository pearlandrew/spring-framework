{
  HttpServletRequest processedRequest=request;
  HandlerExecutionChain mappedHandler=null;
  AsyncExecutionChain asyncChain=AsyncExecutionChain.getForCurrentRequest(request);
  try {
    ModelAndView mv=null;
    Exception dispatchException=null;
    try {
      processedRequest=checkMultipart(request);
      mappedHandler=getHandler(processedRequest,false);
      if (mappedHandler == null || mappedHandler.getHandler() == null) {
        noHandlerFound(processedRequest,response);
        return;
      }
      HandlerAdapter ha=getHandlerAdapter(mappedHandler.getHandler());
      String method=request.getMethod();
      boolean isGet="GET".equals(method);
      if (isGet || "HEAD".equals(method)) {
        long lastModified=ha.getLastModified(request,mappedHandler.getHandler());
        if (logger.isDebugEnabled()) {
          String requestUri=urlPathHelper.getRequestUri(request);
          logger.debug("Last-Modified value for [" + requestUri + "] is: "+ lastModified);
        }
        if (new ServletWebRequest(request,response).checkNotModified(lastModified) && isGet) {
          return;
        }
      }
      if (!mappedHandler.applyPreHandle(processedRequest,response)) {
        return;
      }
      asyncChain.addDelegatingCallable(getDispatchAsyncCallable(mappedHandler,request,response,processedRequest));
      mv=ha.handle(processedRequest,response,mappedHandler.getHandler());
      if (asyncChain.isAsyncStarted()) {
        logger.debug("Exiting request thread and leaving the response open");
        return;
      }
      applyDefaultViewName(request,mv);
      mappedHandler.applyPostHandle(processedRequest,response,mv);
    }
 catch (    Exception ex) {
      dispatchException=ex;
    }
    processDispatchResult(processedRequest,response,mappedHandler,mv,dispatchException);
  }
 catch (  Exception ex) {
    triggerAfterCompletion(processedRequest,response,mappedHandler,ex);
  }
catch (  Error err) {
    triggerAfterCompletionWithError(processedRequest,response,mappedHandler,err);
  }
 finally {
    if (asyncChain.isAsyncStarted()) {
      return;
    }
    if (processedRequest != request) {
      cleanupMultipart(processedRequest);
    }
  }
}
