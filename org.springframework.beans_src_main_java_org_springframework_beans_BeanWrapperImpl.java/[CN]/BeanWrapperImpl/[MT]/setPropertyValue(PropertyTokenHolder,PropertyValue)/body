{
  String propertyName=tokens.canonicalName;
  String actualName=tokens.actualName;
  if (tokens.keys != null) {
    PropertyTokenHolder getterTokens=new PropertyTokenHolder();
    getterTokens.canonicalName=tokens.canonicalName;
    getterTokens.actualName=tokens.actualName;
    getterTokens.keys=new String[tokens.keys.length - 1];
    System.arraycopy(tokens.keys,0,getterTokens.keys,0,tokens.keys.length - 1);
    Object propValue;
    try {
      propValue=getPropertyValue(getterTokens);
    }
 catch (    NotReadablePropertyException ex) {
      throw new NotWritablePropertyException(getRootClass(),this.nestedPath + propertyName,"Cannot access indexed value in property referenced " + "in indexed property path '" + propertyName + "'",ex);
    }
    String key=tokens.keys[tokens.keys.length - 1];
    if (propValue == null) {
      throw new NullValueInNestedPathException(getRootClass(),this.nestedPath + propertyName,"Cannot access indexed value in property referenced " + "in indexed property path '" + propertyName + "': returned null");
    }
 else     if (propValue.getClass().isArray()) {
      Class requiredType=propValue.getClass().getComponentType();
      int arrayIndex=Integer.parseInt(key);
      Object oldValue=null;
      try {
        if (isExtractOldValueForEditor()) {
          oldValue=Array.get(propValue,arrayIndex);
        }
        Object convertedValue=this.typeConverterDelegate.convertIfNecessary(propertyName,oldValue,pv.getValue(),requiredType);
        Array.set(propValue,Integer.parseInt(key),convertedValue);
      }
 catch (      IllegalArgumentException ex) {
        PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
        throw new TypeMismatchException(pce,requiredType,ex);
      }
catch (      IllegalStateException ex) {
        PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
        throw new ConversionNotSupportedException(pce,requiredType,ex);
      }
catch (      IndexOutOfBoundsException ex) {
        throw new InvalidPropertyException(getRootClass(),this.nestedPath + propertyName,"Invalid array index in property path '" + propertyName + "'",ex);
      }
    }
 else     if (propValue instanceof List) {
      PropertyDescriptor pd=getCachedIntrospectionResults().getPropertyDescriptor(actualName);
      Class requiredType=GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(),tokens.keys.length);
      List list=(List)propValue;
      int index=Integer.parseInt(key);
      Object oldValue=null;
      if (isExtractOldValueForEditor() && index < list.size()) {
        oldValue=list.get(index);
      }
      try {
        Object convertedValue=this.typeConverterDelegate.convertIfNecessary(propertyName,oldValue,pv.getValue(),requiredType);
        if (index < list.size()) {
          list.set(index,convertedValue);
        }
 else         if (index >= list.size()) {
          for (int i=list.size(); i < index; i++) {
            try {
              list.add(null);
            }
 catch (            NullPointerException ex) {
              throw new InvalidPropertyException(getRootClass(),this.nestedPath + propertyName,"Cannot set element with index " + index + " in List of size "+ list.size()+ ", accessed using property path '"+ propertyName+ "': List does not support filling up gaps with null elements");
            }
          }
          list.add(convertedValue);
        }
      }
 catch (      IllegalArgumentException ex) {
        PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
        throw new TypeMismatchException(pce,requiredType,ex);
      }
    }
 else     if (propValue instanceof Map) {
      PropertyDescriptor pd=getCachedIntrospectionResults().getPropertyDescriptor(actualName);
      Class mapKeyType=GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(),tokens.keys.length);
      Class mapValueType=GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(),tokens.keys.length);
      Map map=(Map)propValue;
      Object convertedMapKey;
      Object convertedMapValue;
      try {
        convertedMapKey=this.typeConverterDelegate.convertIfNecessary(key,mapKeyType);
      }
 catch (      IllegalArgumentException ex) {
        PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,null,pv.getValue());
        throw new TypeMismatchException(pce,mapKeyType,ex);
      }
      Object oldValue=null;
      if (isExtractOldValueForEditor()) {
        oldValue=map.get(convertedMapKey);
      }
      try {
        convertedMapValue=this.typeConverterDelegate.convertIfNecessary(propertyName,oldValue,pv.getValue(),mapValueType,null,new MethodParameter(pd.getReadMethod(),-1,tokens.keys.length + 1));
      }
 catch (      IllegalArgumentException ex) {
        PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
        throw new TypeMismatchException(pce,mapValueType,ex);
      }
      map.put(convertedMapKey,convertedMapValue);
    }
 else {
      throw new InvalidPropertyException(getRootClass(),this.nestedPath + propertyName,"Property referenced in indexed property path '" + propertyName + "' is neither an array nor a List nor a Map; returned value was ["+ pv.getValue()+ "]");
    }
  }
 else {
    PropertyDescriptor pd=pv.resolvedDescriptor;
    if (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {
      pd=getCachedIntrospectionResults().getPropertyDescriptor(actualName);
      if (pd == null || pd.getWriteMethod() == null) {
        PropertyMatches matches=PropertyMatches.forProperty(propertyName,getRootClass());
        throw new NotWritablePropertyException(getRootClass(),this.nestedPath + propertyName,matches.buildErrorMessage(),matches.getPossibleMatches());
      }
      pv.getOriginalPropertyValue().resolvedDescriptor=pd;
    }
    Object oldValue=null;
    try {
      Object originalValue=pv.getValue();
      Object valueToApply=originalValue;
      if (!Boolean.FALSE.equals(pv.conversionNecessary)) {
        if (pv.isConverted()) {
          valueToApply=pv.getConvertedValue();
        }
 else {
          if (isExtractOldValueForEditor() && pd.getReadMethod() != null) {
            final Method readMethod=pd.getReadMethod();
            if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) && !readMethod.isAccessible()) {
              if (System.getSecurityManager() != null) {
                AccessController.doPrivileged(new PrivilegedAction<Object>(){
                  public Object run(){
                    readMethod.setAccessible(true);
                    return null;
                  }
                }
);
              }
 else {
                readMethod.setAccessible(true);
              }
            }
            try {
              if (System.getSecurityManager() != null) {
                oldValue=AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){
                  public Object run() throws Exception {
                    return readMethod.invoke(object);
                  }
                }
,acc);
              }
 else {
                oldValue=readMethod.invoke(object);
              }
            }
 catch (            Exception ex) {
              if (ex instanceof PrivilegedActionException) {
                ex=((PrivilegedActionException)ex).getException();
              }
              if (logger.isDebugEnabled()) {
                logger.debug("Could not read previous value of property '" + this.nestedPath + propertyName+ "'",ex);
              }
            }
          }
          valueToApply=this.typeConverterDelegate.convertIfNecessary(oldValue,originalValue,pd);
        }
        pv.getOriginalPropertyValue().conversionNecessary=(valueToApply != originalValue);
      }
      final Method writeMethod=pd.getWriteMethod();
      if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {
        if (System.getSecurityManager() != null) {
          AccessController.doPrivileged(new PrivilegedAction<Object>(){
            public Object run(){
              writeMethod.setAccessible(true);
              return null;
            }
          }
);
        }
 else {
          writeMethod.setAccessible(true);
        }
      }
      final Object value=valueToApply;
      if (System.getSecurityManager() != null) {
        try {
          AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){
            public Object run() throws Exception {
              writeMethod.invoke(object,value);
              return null;
            }
          }
,acc);
        }
 catch (        PrivilegedActionException ex) {
          throw ex.getException();
        }
      }
 else {
        writeMethod.invoke(object,value);
      }
    }
 catch (    InvocationTargetException ex) {
      PropertyChangeEvent propertyChangeEvent=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
      if (ex.getTargetException() instanceof ClassCastException) {
        throw new TypeMismatchException(propertyChangeEvent,pd.getPropertyType(),ex.getTargetException());
      }
 else {
        throw new MethodInvocationException(propertyChangeEvent,ex.getTargetException());
      }
    }
catch (    ConversionException ex) {
      PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
      throw new TypeMismatchException(pce,pd.getPropertyType(),ex);
    }
catch (    IllegalArgumentException ex) {
      PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
      throw new TypeMismatchException(pce,pd.getPropertyType(),ex);
    }
catch (    IllegalStateException ex) {
      PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
      throw new ConversionNotSupportedException(pce,pd.getPropertyType(),ex);
    }
catch (    IllegalAccessException ex) {
      PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
      throw new MethodInvocationException(pce,ex);
    }
catch (    Exception ex) {
      PropertyChangeEvent pce=new PropertyChangeEvent(this.rootObject,this.nestedPath + propertyName,oldValue,pv.getValue());
      throw new MethodInvocationException(pce,ex);
    }
  }
}
