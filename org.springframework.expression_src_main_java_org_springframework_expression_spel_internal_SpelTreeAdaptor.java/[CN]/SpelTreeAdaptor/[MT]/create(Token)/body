{
  if (payload != null) {
switch (payload.getType()) {
case SpringExpressionsLexer.EXPRESSIONLIST:
      return new ExpressionListNode(payload);
case SpringExpressionsLexer.TRUE:
    return new BooleanLiteral(payload,true);
case SpringExpressionsLexer.FALSE:
  return new BooleanLiteral(payload,false);
case SpringExpressionsLexer.OR:
return new OperatorOr(payload);
case SpringExpressionsLexer.AND:
return new OperatorAnd(payload);
case SpringExpressionsLexer.BANG:
return new OperatorNot(payload);
case SpringExpressionsLexer.REAL_LITERAL:
return new RealLiteral(payload);
case SpringExpressionsLexer.INTEGER_LITERAL:
return Literal.getIntLiteral(payload,10);
case SpringExpressionsLexer.HEXADECIMAL_INTEGER_LITERAL:
return Literal.getIntLiteral(payload,16);
case SpringExpressionsLexer.NOT_EQUAL:
return new OperatorInequality(payload);
case SpringExpressionsLexer.EQUAL:
return new OperatorEquality(payload);
case SpringExpressionsLexer.GREATER_THAN:
return new OperatorGreaterThan(payload);
case SpringExpressionsLexer.LESS_THAN:
return new OperatorLessThan(payload);
case SpringExpressionsLexer.LESS_THAN_OR_EQUAL:
return new OperatorLessThanOrEqual(payload);
case SpringExpressionsLexer.GREATER_THAN_OR_EQUAL:
return new OperatorGreaterThanOrEqual(payload);
case SpringExpressionsLexer.SOUNDSLIKE:
return new OperatorSoundsLike(payload);
case SpringExpressionsLexer.DISTANCETO:
return new OperatorDistanceTo(payload);
case SpringExpressionsLexer.PLUS:
return new OperatorPlus(payload);
case SpringExpressionsLexer.MINUS:
return new OperatorMinus(payload);
case SpringExpressionsLexer.STAR:
return new OperatorMultiply(payload);
case SpringExpressionsLexer.DIV:
return new OperatorDivide(payload);
case SpringExpressionsLexer.MOD:
return new OperatorModulus(payload);
case SpringExpressionsLexer.STRING_LITERAL:
case SpringExpressionsLexer.DQ_STRING_LITERAL:
return new StringLiteral(payload);
case SpringExpressionsLexer.NULL_LITERAL:
return new NullLiteral(payload);
case SpringExpressionsLexer.DATE_LITERAL:
return new DateLiteral(payload);
case SpringExpressionsLexer.ID:
return new Identifier(payload);
case SpringExpressionsLexer.PROPERTY_OR_FIELD:
return new PropertyOrFieldReference(payload);
case SpringExpressionsLexer.METHOD:
return new MethodReference(payload);
case SpringExpressionsLexer.QUALIFIED_IDENTIFIER:
return new QualifiedIdentifier(payload);
case SpringExpressionsLexer.REFERENCE:
return new Reference(payload);
case SpringExpressionsLexer.TYPEREF:
return new TypeReference(payload);
case SpringExpressionsLexer.EXPRESSION:
return new CompoundExpression(payload);
case SpringExpressionsLexer.LIST_INITIALIZER:
return new ListInitializer(payload);
case SpringExpressionsLexer.MAP_ENTRY:
return new MapEntry(payload);
case SpringExpressionsLexer.MAP_INITIALIZER:
return new MapInitializer(payload);
case SpringExpressionsLexer.CONSTRUCTOR:
return new ConstructorReference(payload,false);
case SpringExpressionsLexer.CONSTRUCTOR_ARRAY:
return new ConstructorReference(payload,true);
case SpringExpressionsLexer.LOCALFUNC:
return new LocalFunctionReference(payload);
case SpringExpressionsLexer.LOCALVAR:
return new LocalVariableReference(payload);
case SpringExpressionsLexer.VARIABLEREF:
return new VariableReference(payload);
case SpringExpressionsLexer.FUNCTIONREF:
return new FunctionReference(payload);
case SpringExpressionsLexer.PROJECT:
return new Projection(payload);
case SpringExpressionsLexer.SELECT:
return new Selection(payload,Selection.ALL);
case SpringExpressionsLexer.SELECT_FIRST:
return new Selection(payload,Selection.FIRST);
case SpringExpressionsLexer.SELECT_LAST:
return new Selection(payload,Selection.LAST);
case SpringExpressionsLexer.ASSIGN:
return new Assign(payload);
case SpringExpressionsLexer.QMARK:
return new Ternary(payload);
case SpringExpressionsLexer.INDEXER:
return new Indexer(payload);
case SpringExpressionsLexer.IN:
return new OperatorIn(payload);
case SpringExpressionsLexer.LIKE:
return new OperatorLike(payload);
case SpringExpressionsLexer.BETWEEN:
return new OperatorBetween(payload);
case SpringExpressionsLexer.MATCHES:
return new OperatorMatches(payload);
case SpringExpressionsLexer.IS:
return new OperatorIs(payload);
case SpringExpressionsLexer.ARGLIST:
return new ArgList(payload);
case SpringExpressionsLexer.LAMBDA:
return new Lambda(payload);
case SpringExpressionsLexer.RPAREN:
return new Placeholder(payload);
case SpringExpressionsLexer.COLON:
return new Placeholder(payload);
case SpringExpressionsLexer.DOT:
return new Dot(payload);
default :
throw new RuntimeException("Not implemented for '" + payload + "' "+ getToken(payload)+ "'   "+ payload.getType());
}
}
return new EmptySpelNode(payload);
}
