{
  Class<?> clazz=getBootstrapContext().getTestClass();
  Class<TestExecutionListeners> annotationType=TestExecutionListeners.class;
  List<Class<? extends TestExecutionListener>> classesList=new ArrayList<Class<? extends TestExecutionListener>>();
  AnnotationDescriptor<TestExecutionListeners> descriptor=MetaAnnotationUtils.findAnnotationDescriptor(clazz,annotationType);
  if (descriptor == null) {
    if (logger.isDebugEnabled()) {
      logger.debug("@TestExecutionListeners is not present for class [" + clazz.getName() + "]: using defaults.");
    }
    classesList.addAll(getDefaultTestExecutionListenerClasses());
  }
 else {
    while (descriptor != null) {
      Class<?> declaringClass=descriptor.getDeclaringClass();
      AnnotationAttributes annAttrs=descriptor.getAnnotationAttributes();
      if (logger.isTraceEnabled()) {
        logger.trace(String.format("Retrieved @TestExecutionListeners attributes [%s] for declaring class [%s].",annAttrs,declaringClass.getName()));
      }
      Class<? extends TestExecutionListener>[] valueListenerClasses=(Class<? extends TestExecutionListener>[])annAttrs.getClassArray("value");
      Class<? extends TestExecutionListener>[] listenerClasses=(Class<? extends TestExecutionListener>[])annAttrs.getClassArray("listeners");
      if (!ObjectUtils.isEmpty(valueListenerClasses) && !ObjectUtils.isEmpty(listenerClasses)) {
        throw new IllegalStateException(String.format("Class [%s] configured with @TestExecutionListeners' " + "'value' [%s] and 'listeners' [%s] attributes. Use one or the other, but not both.",declaringClass.getName(),ObjectUtils.nullSafeToString(valueListenerClasses),ObjectUtils.nullSafeToString(listenerClasses)));
      }
 else       if (!ObjectUtils.isEmpty(valueListenerClasses)) {
        listenerClasses=valueListenerClasses;
      }
      if (listenerClasses != null) {
        classesList.addAll(0,Arrays.<Class<? extends TestExecutionListener>>asList(listenerClasses));
      }
      descriptor=(annAttrs.getBoolean("inheritListeners") ? MetaAnnotationUtils.findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(),annotationType) : null);
    }
  }
  List<TestExecutionListener> listeners=new ArrayList<TestExecutionListener>(classesList.size());
  for (  Class<? extends TestExecutionListener> listenerClass : classesList) {
    NoClassDefFoundError ncdfe=null;
    try {
      listeners.add(BeanUtils.instantiateClass(listenerClass));
    }
 catch (    NoClassDefFoundError err) {
      ncdfe=err;
    }
catch (    BeanInstantiationException ex) {
      if (ex.getCause() instanceof NoClassDefFoundError) {
        ncdfe=(NoClassDefFoundError)ex.getCause();
      }
    }
    if (ncdfe != null) {
      if (logger.isInfoEnabled()) {
        logger.info(String.format("Could not instantiate TestExecutionListener [%s]. " + "Specify custom listener classes or make the default listener classes " + "(and their required dependencies) available. Offending class: [%s]",listenerClass.getName(),ncdfe.getMessage()));
      }
    }
  }
  return listeners;
}
