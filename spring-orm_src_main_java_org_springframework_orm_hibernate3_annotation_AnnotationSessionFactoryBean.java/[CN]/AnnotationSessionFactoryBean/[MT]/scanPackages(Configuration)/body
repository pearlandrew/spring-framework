{
  if (this.packagesToScan != null) {
    Set<String> classNames=new TreeSet<String>();
    Set<String> packageNames=new TreeSet<String>();
    try {
      for (      String pkg : this.packagesToScan) {
        String pattern=ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(pkg) + RESOURCE_PATTERN;
        Resource[] resources=this.resourcePatternResolver.getResources(pattern);
        MetadataReaderFactory readerFactory=new CachingMetadataReaderFactory(this.resourcePatternResolver);
        for (        Resource resource : resources) {
          if (resource.isReadable()) {
            MetadataReader reader=readerFactory.getMetadataReader(resource);
            String className=reader.getClassMetadata().getClassName();
            if (matchesEntityTypeFilter(reader,readerFactory)) {
              classNames.add(className);
            }
 else             if (className.endsWith(PACKAGE_INFO_SUFFIX)) {
              packageNames.add(className.substring(0,className.length() - PACKAGE_INFO_SUFFIX.length()));
            }
          }
        }
      }
    }
 catch (    IOException ex) {
      throw new MappingException("Failed to scan classpath for unlisted classes",ex);
    }
    try {
      for (      String className : classNames) {
        config.addAnnotatedClass(this.resourcePatternResolver.getClassLoader().loadClass(className));
      }
      for (      String packageName : packageNames) {
        config.addPackage(packageName);
      }
    }
 catch (    ClassNotFoundException ex) {
      throw new MappingException("Failed to load annotated classes from classpath",ex);
    }
  }
}
