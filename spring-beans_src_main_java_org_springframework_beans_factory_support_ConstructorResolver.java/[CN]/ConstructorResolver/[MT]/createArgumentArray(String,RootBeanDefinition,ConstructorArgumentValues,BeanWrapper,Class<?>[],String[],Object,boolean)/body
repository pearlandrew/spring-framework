{
  String methodType=(methodOrCtor instanceof Constructor ? "constructor" : "factory method");
  TypeConverter converter=(this.beanFactory.getCustomTypeConverter() != null ? this.beanFactory.getCustomTypeConverter() : bw);
  ArgumentsHolder args=new ArgumentsHolder(paramTypes.length);
  Set<ConstructorArgumentValues.ValueHolder> usedValueHolders=new HashSet<ConstructorArgumentValues.ValueHolder>(paramTypes.length);
  Set<String> autowiredBeanNames=new LinkedHashSet<String>(4);
  for (int paramIndex=0; paramIndex < paramTypes.length; paramIndex++) {
    Class<?> paramType=paramTypes[paramIndex];
    String paramName=(paramNames != null ? paramNames[paramIndex] : null);
    ConstructorArgumentValues.ValueHolder valueHolder=resolvedValues.getArgumentValue(paramIndex,paramType,paramName,usedValueHolders);
    if (valueHolder == null && (!autowiring || paramTypes.length == resolvedValues.getArgumentCount())) {
      valueHolder=resolvedValues.getGenericArgumentValue(null,null,usedValueHolders);
    }
    if (valueHolder != null) {
      usedValueHolders.add(valueHolder);
      Object originalValue=valueHolder.getValue();
      Object convertedValue;
      if (valueHolder.isConverted()) {
        convertedValue=valueHolder.getConvertedValue();
        args.preparedArguments[paramIndex]=convertedValue;
      }
 else {
        ConstructorArgumentValues.ValueHolder sourceHolder=(ConstructorArgumentValues.ValueHolder)valueHolder.getSource();
        Object sourceValue=sourceHolder.getValue();
        try {
          convertedValue=converter.convertIfNecessary(originalValue,paramType,MethodParameter.forMethodOrConstructor(methodOrCtor,paramIndex));
          args.resolveNecessary=true;
          args.preparedArguments[paramIndex]=sourceValue;
        }
 catch (        TypeMismatchException ex) {
          throw new UnsatisfiedDependencyException(mbd.getResourceDescription(),beanName,paramIndex,paramType,"Could not convert " + methodType + " argument value of type ["+ ObjectUtils.nullSafeClassName(valueHolder.getValue())+ "] to required type ["+ paramType.getName()+ "]: "+ ex.getMessage());
        }
      }
      args.arguments[paramIndex]=convertedValue;
      args.rawArguments[paramIndex]=originalValue;
    }
 else {
      if (!autowiring) {
        throw new UnsatisfiedDependencyException(mbd.getResourceDescription(),beanName,paramIndex,paramType,"Ambiguous " + methodType + " argument types - "+ "did you specify the correct bean references as "+ methodType+ " arguments?");
      }
      try {
        MethodParameter param=MethodParameter.forMethodOrConstructor(methodOrCtor,paramIndex);
        Object autowiredArgument=resolveAutowiredArgument(param,beanName,autowiredBeanNames,converter);
        args.rawArguments[paramIndex]=autowiredArgument;
        args.arguments[paramIndex]=autowiredArgument;
        args.preparedArguments[paramIndex]=new AutowiredArgumentMarker();
        args.resolveNecessary=true;
      }
 catch (      BeansException ex) {
        throw new UnsatisfiedDependencyException(mbd.getResourceDescription(),beanName,paramIndex,paramType,ex);
      }
    }
  }
  for (  String autowiredBeanName : autowiredBeanNames) {
    this.beanFactory.registerDependentBean(autowiredBeanName,beanName);
    if (this.beanFactory.logger.isDebugEnabled()) {
      this.beanFactory.logger.debug("Autowiring by type from bean name '" + beanName + "' via "+ methodType+ " to bean named '"+ autowiredBeanName+ "'");
    }
  }
  return args;
}
