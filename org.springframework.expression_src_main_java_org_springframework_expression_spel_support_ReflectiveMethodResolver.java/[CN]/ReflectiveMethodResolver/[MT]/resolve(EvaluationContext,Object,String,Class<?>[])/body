{
  try {
    TypeConverter typeConverter=context.getTypeConverter();
    Class<?> type=(targetObject instanceof Class ? (Class<?>)targetObject : targetObject.getClass());
    Method[] methods=type.getMethods();
    MethodFilter methodfilter=(filters == null ? null : filters.get(type));
    if (methodfilter != null) {
      List<Method> methodsForFiltering=new ArrayList<Method>();
      for (      Method method : methods) {
        methodsForFiltering.add(method);
      }
      List<Method> methodsFiltered=methodfilter.filter(methodsForFiltering);
      if (methodsFiltered == null || methodsFiltered.size() == 0) {
        methods=NO_METHODS;
      }
 else {
        methods=methodsFiltered.toArray(new Method[methodsFiltered.size()]);
      }
    }
    Method closeMatch=null;
    int[] argsToConvert=null;
    boolean multipleOptions=false;
    Method matchRequiringConversion=null;
    for (    Method method : methods) {
      if (method.isBridge()) {
        continue;
      }
      if (method.getName().equals(name)) {
        ReflectionHelper.ArgumentsMatchInfo matchInfo=null;
        if (method.isVarArgs() && argumentTypes.length >= (method.getParameterTypes().length - 1)) {
          matchInfo=ReflectionHelper.compareArgumentsVarargs(method.getParameterTypes(),argumentTypes,typeConverter);
        }
 else         if (method.getParameterTypes().length == argumentTypes.length) {
          matchInfo=ReflectionHelper.compareArguments(method.getParameterTypes(),argumentTypes,typeConverter);
        }
        if (matchInfo != null) {
          if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {
            return new ReflectiveMethodExecutor(method,null);
          }
 else           if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {
            closeMatch=method;
          }
 else           if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {
            if (matchRequiringConversion != null) {
              multipleOptions=true;
            }
            argsToConvert=matchInfo.argsRequiringConversion;
            matchRequiringConversion=method;
          }
        }
      }
    }
    if (closeMatch != null) {
      return new ReflectiveMethodExecutor(closeMatch,null);
    }
 else     if (matchRequiringConversion != null) {
      if (multipleOptions) {
        throw new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS,name);
      }
      return new ReflectiveMethodExecutor(matchRequiringConversion,argsToConvert);
    }
 else {
      return null;
    }
  }
 catch (  EvaluationException ex) {
    throw new AccessException("Failed to resolve method",ex);
  }
}
