{
  if (logger.isTraceEnabled()) {
    logger.trace("Processing: " + stompMessage);
  }
  try {
    MessageType messageType=MessageType.OTHER;
    String replyKey=null;
    StompCommand command=stompMessage.getCommand();
    if (StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command)) {
      session.registerConnectionClosedTask(new ConnectionClosedTask(session));
      messageType=MessageType.CONNECT;
      replyKey=handleConnect(session,stompMessage);
    }
 else     if (StompCommand.SEND.equals(command)) {
      messageType=MessageType.MESSAGE;
      handleSend(session,stompMessage);
    }
 else     if (StompCommand.SUBSCRIBE.equals(command)) {
      messageType=MessageType.SUBSCRIBE;
      replyKey=handleSubscribe(session,stompMessage);
    }
 else     if (StompCommand.UNSUBSCRIBE.equals(command)) {
      messageType=MessageType.UNSUBSCRIBE;
      handleUnsubscribe(session,stompMessage);
    }
 else     if (StompCommand.DISCONNECT.equals(command)) {
      messageType=MessageType.DISCONNECT;
      handleDisconnect(session,stompMessage);
    }
 else {
      sendErrorMessage(session,"Invalid STOMP command " + command);
      return;
    }
    Map<String,Object> messageHeaders=this.headerMapper.toMessageHeaders(stompMessage.getHeaders());
    messageHeaders.put("messageType",messageType);
    if (replyKey != null) {
      messageHeaders.put(MessageHeaders.REPLY_CHANNEL,replyKey);
    }
    messageHeaders.put("stompCommand",command);
    messageHeaders.put("sessionId",session.getId());
    Message<byte[]> genericMessage=new GenericMessage<byte[]>(stompMessage.getPayload(),messageHeaders);
    if (logger.isTraceEnabled()) {
      logger.trace("Sending notification: " + genericMessage);
    }
    this.eventBus.send(AbstractMessageService.MESSAGE_KEY,genericMessage);
  }
 catch (  Throwable t) {
    handleError(session,t);
  }
}
