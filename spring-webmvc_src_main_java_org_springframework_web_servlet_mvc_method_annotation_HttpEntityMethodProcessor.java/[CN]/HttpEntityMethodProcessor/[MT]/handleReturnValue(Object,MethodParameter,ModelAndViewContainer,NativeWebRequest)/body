{
  mavContainer.setRequestHandled(true);
  if (returnValue == null) {
    return;
  }
  ServletServerHttpRequest inputMessage=createInputMessage(webRequest);
  ServletServerHttpResponse outputMessage=createOutputMessage(webRequest);
  Assert.isInstanceOf(HttpEntity.class,returnValue);
  HttpEntity<?> responseEntity=(HttpEntity<?>)returnValue;
  HttpHeaders outputHeaders=outputMessage.getHeaders();
  HttpHeaders entityHeaders=responseEntity.getHeaders();
  if (outputHeaders.containsKey(HttpHeaders.VARY) && entityHeaders.containsKey(HttpHeaders.VARY)) {
    List<String> values=getVaryRequestHeadersToAdd(outputHeaders,entityHeaders);
    if (!values.isEmpty()) {
      outputHeaders.setVary(values);
    }
  }
  if (!entityHeaders.isEmpty()) {
    for (    Map.Entry<String,List<String>> entry : entityHeaders.entrySet()) {
      if (!outputHeaders.containsKey(entry.getKey())) {
        outputHeaders.put(entry.getKey(),entry.getValue());
      }
    }
  }
  Object body=responseEntity.getBody();
  if (responseEntity instanceof ResponseEntity) {
    outputMessage.setStatusCode(((ResponseEntity<?>)responseEntity).getStatusCode());
    HttpMethod method=inputMessage.getMethod();
    boolean isGetOrHead=(HttpMethod.GET == method || HttpMethod.HEAD == method);
    if (isGetOrHead && isResourceNotModified(inputMessage,outputMessage)) {
      outputMessage.setStatusCode(HttpStatus.NOT_MODIFIED);
      outputMessage.flush();
      return;
    }
  }
  if (inputMessage.getHeaders().containsKey(HttpHeaders.RANGE) && Resource.class.isAssignableFrom(body.getClass())) {
    try {
      List<HttpRange> httpRanges=inputMessage.getHeaders().getRange();
      Resource bodyResource=(Resource)body;
      body=new HttpRangeResource(httpRanges,bodyResource);
      outputMessage.setStatusCode(HttpStatus.PARTIAL_CONTENT);
    }
 catch (    IllegalArgumentException ex) {
      outputMessage.setStatusCode(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE);
      outputMessage.flush();
      return;
    }
  }
  writeWithMessageConverters(body,returnType,inputMessage,outputMessage);
  outputMessage.flush();
}
