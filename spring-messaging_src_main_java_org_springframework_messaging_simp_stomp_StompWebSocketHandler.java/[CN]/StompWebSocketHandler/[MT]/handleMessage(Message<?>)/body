{
  StompHeaderAccessor headers=StompHeaderAccessor.wrap(message);
  headers.setCommandIfNotSet(StompCommand.MESSAGE);
  if (StompCommand.CONNECTED.equals(headers.getCommand())) {
    return;
  }
  String sessionId=headers.getSessionId();
  if (sessionId == null) {
    logger.error("Ignoring message, no sessionId header: " + message);
    return;
  }
  WebSocketSession session=this.sessions.get(sessionId);
  if (session == null) {
    logger.error("Ignoring message, sessionId not found: " + message);
    return;
  }
  if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {
    logger.error("Ignoring message, no subscriptionId header: " + message);
    return;
  }
  if (!(message.getPayload() instanceof byte[])) {
    logger.error("Ignoring message, expected byte[] content: " + message);
    return;
  }
  try {
    message=MessageBuilder.withPayloadAndHeaders(message.getPayload(),headers).build();
    byte[] bytes=this.stompMessageConverter.fromMessage(message);
    session.sendMessage(new TextMessage(new String(bytes,Charset.forName("UTF-8"))));
  }
 catch (  Throwable t) {
    sendErrorMessage(session,t);
  }
 finally {
    if (StompCommand.ERROR.equals(headers.getCommand())) {
      try {
        session.close(CloseStatus.PROTOCOL_ERROR);
      }
 catch (      IOException e) {
      }
    }
  }
}
