{
  final SessionFactory sf=createStrictMock(SessionFactory.class);
  final Session session=createStrictMock(Session.class);
  expect(sf.openSession()).andReturn(session);
  expect(session.getSessionFactory()).andReturn(sf);
  expect(session.getFlushMode()).andReturn(FlushMode.MANUAL);
  session.setFlushMode(FlushMode.MANUAL);
  replay(sf);
  replay(session);
  final SessionFactory sf2=createStrictMock(SessionFactory.class);
  final Session session2=createStrictMock(Session.class);
  Transaction tx=createStrictMock(Transaction.class);
  Connection con=createStrictMock(Connection.class);
  expect(sf2.openSession()).andReturn(session2);
  expect(session2.connection()).andReturn(con);
  expect(session2.beginTransaction()).andReturn(tx);
  expect(session2.isConnected()).andReturn(true);
  expect(session2.connection()).andReturn(con);
  tx.commit();
  expect(con.isReadOnly()).andReturn(false);
  session2.setFlushMode(FlushMode.MANUAL);
  replay(sf2);
  replay(session2);
  replay(tx);
  replay(con);
  StaticWebApplicationContext wac=new StaticWebApplicationContext();
  wac.setServletContext(sc);
  wac.getDefaultListableBeanFactory().registerSingleton("sessionFactory",sf);
  wac.getDefaultListableBeanFactory().registerSingleton("mySessionFactory",sf2);
  wac.refresh();
  sc.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,wac);
  MockFilterConfig filterConfig=new MockFilterConfig(wac.getServletContext(),"filter");
  MockFilterConfig filterConfig2=new MockFilterConfig(wac.getServletContext(),"filter2");
  filterConfig.addInitParameter("singleSession","false");
  filterConfig2.addInitParameter("singleSession","false");
  filterConfig2.addInitParameter("sessionFactoryBeanName","mySessionFactory");
  final OpenSessionInViewFilter filter=new OpenSessionInViewFilter();
  filter.init(filterConfig);
  final OpenSessionInViewFilter filter2=new OpenSessionInViewFilter();
  filter2.init(filterConfig2);
  final FilterChain filterChain=new FilterChain(){
    public void doFilter(    ServletRequest servletRequest,    ServletResponse servletResponse){
      HibernateTransactionManager tm=new HibernateTransactionManager(sf);
      TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition(TransactionDefinition.PROPAGATION_SUPPORTS));
      org.hibernate.Session sess=SessionFactoryUtils.getSession(sf,true);
      SessionFactoryUtils.releaseSession(sess,sf);
      tm.commit(ts);
      verify(session);
      reset(session);
      expect(session.close()).andReturn(null);
      replay(session);
      servletRequest.setAttribute("invoked",Boolean.TRUE);
    }
  }
;
  final FilterChain filterChain2=new FilterChain(){
    public void doFilter(    ServletRequest servletRequest,    ServletResponse servletResponse) throws IOException, ServletException {
      HibernateTransactionManager tm=new HibernateTransactionManager(sf2);
      TransactionStatus ts=tm.getTransaction(new DefaultTransactionDefinition());
      tm.commit(ts);
      verify(session2);
      reset(session2);
      expect(session2.close()).andReturn(null);
      replay(session2);
      filter.doFilter(servletRequest,servletResponse,filterChain);
    }
  }
;
  FilterChain filterChain3=new PassThroughFilterChain(filter2,filterChain2);
  filter2.doFilter(this.request,this.response,filterChain3);
  assertNotNull(this.request.getAttribute("invoked"));
  verify(sf);
  verify(session);
  verify(sf2);
  verify(session2);
  verify(tx);
  verify(con);
  wac.close();
}
