{
  final SessionFactory sf=mock(SessionFactory.class);
  Session session=mock(Session.class);
  given(sf.openSession()).willReturn(session);
  given(session.getSessionFactory()).willReturn(sf);
  StaticWebApplicationContext wac=new StaticWebApplicationContext();
  wac.setServletContext(sc);
  wac.getDefaultListableBeanFactory().registerSingleton("sessionFactory",sf);
  wac.refresh();
  sc.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,wac);
  MockFilterConfig filterConfig=new MockFilterConfig(wac.getServletContext(),"filter");
  final OpenSessionInViewFilter filter=new OpenSessionInViewFilter();
  filter.init(filterConfig);
  final AtomicInteger count=new AtomicInteger(0);
  final AsyncWebRequest asyncWebRequest=new StandardServletAsyncWebRequest(this.request,this.response);
  final MockHttpServletRequest request=this.request;
  final FilterChain filterChain=new FilterChain(){
    @Override public void doFilter(    ServletRequest servletRequest,    ServletResponse servletResponse) throws NestedServletException {
      assertTrue(TransactionSynchronizationManager.hasResource(sf));
      count.incrementAndGet();
      WebAsyncManager asyncManager=WebAsyncUtils.getAsyncManager(request);
      asyncManager.setTaskExecutor(new SyncTaskExecutor());
      asyncManager.setAsyncWebRequest(asyncWebRequest);
      try {
        asyncManager.startCallableProcessing(new Callable<String>(){
          @Override public String call() throws Exception {
            return "anything";
          }
        }
);
      }
 catch (      Exception e) {
        throw new NestedServletException("",e);
      }
    }
  }
;
  assertFalse(TransactionSynchronizationManager.hasResource(sf));
  filter.doFilter(this.request,this.response,filterChain);
  assertFalse(TransactionSynchronizationManager.hasResource(sf));
  assertEquals(1,count.get());
  verify(session,never()).close();
  MockAsyncContext asyncContext=(MockAsyncContext)this.request.getAsyncContext();
  for (  AsyncListener listener : asyncContext.getListeners()) {
    listener.onTimeout(new AsyncEvent(asyncContext));
  }
  for (  AsyncListener listener : asyncContext.getListeners()) {
    listener.onComplete(new AsyncEvent(asyncContext));
  }
  verify(session).close();
  wac.close();
}
