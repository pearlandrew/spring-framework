{
  final SessionFactory sf=mock(SessionFactory.class);
  Session session=mock(Session.class);
  OpenSessionInViewInterceptor interceptor=new OpenSessionInViewInterceptor();
  interceptor.setSessionFactory(sf);
  given(sf.openSession()).willReturn(session);
  given(session.getSessionFactory()).willReturn(sf);
  interceptor.preHandle(this.webRequest);
  assertTrue(TransactionSynchronizationManager.hasResource(sf));
  AsyncWebRequest asyncWebRequest=new StandardServletAsyncWebRequest(this.request,this.response);
  WebAsyncManager asyncManager=WebAsyncUtils.getAsyncManager(this.request);
  asyncManager.setTaskExecutor(new SyncTaskExecutor());
  asyncManager.setAsyncWebRequest(asyncWebRequest);
  asyncManager.startCallableProcessing(new Callable<String>(){
    @Override public String call() throws Exception {
      return "anything";
    }
  }
);
  interceptor.afterConcurrentHandlingStarted(this.webRequest);
  assertFalse(TransactionSynchronizationManager.hasResource(sf));
  verify(session,never()).close();
  MockAsyncContext asyncContext=(MockAsyncContext)this.request.getAsyncContext();
  for (  AsyncListener listener : asyncContext.getListeners()) {
    listener.onTimeout(new AsyncEvent(asyncContext));
  }
  for (  AsyncListener listener : asyncContext.getListeners()) {
    listener.onComplete(new AsyncEvent(asyncContext));
  }
  verify(session).close();
}
