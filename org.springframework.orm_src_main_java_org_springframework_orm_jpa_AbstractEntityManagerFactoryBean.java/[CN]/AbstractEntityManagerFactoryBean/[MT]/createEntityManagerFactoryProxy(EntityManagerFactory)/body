{
  Set<Class> ifcs=new LinkedHashSet<Class>();
  if (this.entityManagerFactoryInterface != null) {
    ifcs.add(this.entityManagerFactoryInterface);
  }
 else {
    ifcs.addAll(ClassUtils.getAllInterfacesForClassAsSet(emf.getClass(),this.beanClassLoader));
  }
  ifcs.add(EntityManagerFactoryInfo.class);
  if (getJpaDialect() != null && getJpaDialect().supportsEntityManagerFactoryPlusOperations()) {
    this.plusOperations=getJpaDialect().getEntityManagerFactoryPlusOperations(emf);
    ifcs.add(EntityManagerFactoryPlusOperations.class);
  }
  try {
    return (EntityManagerFactory)Proxy.newProxyInstance(this.beanClassLoader,ifcs.toArray(new Class[ifcs.size()]),new ManagedEntityManagerFactoryInvocationHandler(this));
  }
 catch (  IllegalArgumentException ex) {
    if (this.entityManagerFactoryInterface != null) {
      throw new IllegalStateException("EntityManagerFactory interface [" + this.entityManagerFactoryInterface + "] seems to conflict with Spring's EntityManagerFactoryInfo mixin - consider resetting the "+ "'entityManagerFactoryInterface' property to plain [javax.persistence.EntityManagerFactory]",ex);
    }
 else {
      throw new IllegalStateException("Conflicting EntityManagerFactory interfaces - " + "consider specifying the 'jpaVendorAdapter' or 'entityManagerFactoryInterface' property " + "to select a specific EntityManagerFactory interface to proceed with",ex);
    }
  }
}
