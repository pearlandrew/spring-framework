{
  Assert.notNull(mvcAsyncTask,"MvcAsyncTask must not be null");
  Assert.state(this.asyncWebRequest != null,"AsyncWebRequest must not be null");
  final Callable<?> callable=mvcAsyncTask.getCallable();
  Long timeout=mvcAsyncTask.getTimeout();
  if (timeout != null) {
    this.asyncWebRequest.setTimeout(timeout);
  }
  AsyncTaskExecutor executor=mvcAsyncTask.getExecutor();
  if (executor != null) {
    this.taskExecutor=executor;
  }
  List<CallableProcessingInterceptor> interceptors=new ArrayList<CallableProcessingInterceptor>();
  interceptors.add(mvcAsyncTask.getInterceptor());
  interceptors.addAll(this.callableInterceptors.values());
  final CallableInterceptorChain interceptorChain=new CallableInterceptorChain(interceptors);
  this.asyncWebRequest.addTimeoutHandler(new Runnable(){
    public void run(){
      logger.debug("Processing timeout");
      Object result=interceptorChain.triggerAfterTimeout(asyncWebRequest,callable);
      if (result != CallableProcessingInterceptor.RESULT_NONE) {
        setConcurrentResultAndDispatch(result);
      }
    }
  }
);
  this.asyncWebRequest.addCompletionHandler(new Runnable(){
    public void run(){
      interceptorChain.triggerAfterCompletion(asyncWebRequest,callable);
    }
  }
);
  startAsyncProcessing(processingContext);
  this.taskExecutor.submit(new Runnable(){
    public void run(){
      Object result=null;
      try {
        interceptorChain.applyPreProcess(asyncWebRequest,callable);
        result=callable.call();
      }
 catch (      Throwable t) {
        result=t;
      }
 finally {
        result=interceptorChain.applyPostProcess(asyncWebRequest,callable,result);
      }
      setConcurrentResultAndDispatch(result);
    }
  }
);
}
