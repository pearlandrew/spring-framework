{
  Set<BeanDefinitionHolder> configCandidates=new LinkedHashSet<BeanDefinitionHolder>();
  String[] candidateNames=registry.getBeanDefinitionNames();
  for (  String beanName : candidateNames) {
    BeanDefinition beanDef=registry.getBeanDefinition(beanName);
    if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
      if (logger.isDebugEnabled()) {
        logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
      }
    }
 else     if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef,this.metadataReaderFactory)) {
      configCandidates.add(new BeanDefinitionHolder(beanDef,beanName));
    }
  }
  if (configCandidates.isEmpty()) {
    return;
  }
  SingletonBeanRegistry singletonRegistry=null;
  if (registry instanceof SingletonBeanRegistry) {
    singletonRegistry=(SingletonBeanRegistry)registry;
    if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {
      BeanNameGenerator generator=(BeanNameGenerator)singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
      this.componentScanBeanNameGenerator=generator;
      this.importBeanNameGenerator=generator;
    }
  }
  ConfigurationClassParser parser=new ConfigurationClassParser(this.metadataReaderFactory,this.problemReporter,this.environment,this.resourceLoader,this.componentScanBeanNameGenerator,registry);
  Set<ConfigurationClass> alreadyParsed=new HashSet<ConfigurationClass>(configCandidates.size());
  do {
    parser.parse(configCandidates);
    parser.validate();
    Set<ConfigurationClass> configClasses=new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());
    configClasses.removeAll(alreadyParsed);
    if (this.reader == null) {
      this.reader=new ConfigurationClassBeanDefinitionReader(registry,this.sourceExtractor,this.problemReporter,this.metadataReaderFactory,this.resourceLoader,this.environment,this.importBeanNameGenerator,parser.getImportRegistry());
    }
    this.reader.loadBeanDefinitions(configClasses);
    alreadyParsed.addAll(configClasses);
    configCandidates.clear();
    if (registry.getBeanDefinitionCount() > candidateNames.length) {
      String[] newCandidateNames=registry.getBeanDefinitionNames();
      Set<String> oldCandidateNames=new HashSet<String>(Arrays.asList(candidateNames));
      Set<String> alreadyParsedClasses=new HashSet<String>();
      for (      ConfigurationClass configurationClass : alreadyParsed) {
        alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
      }
      for (      String candidateName : newCandidateNames) {
        if (!oldCandidateNames.contains(candidateName)) {
          BeanDefinition beanDef=registry.getBeanDefinition(candidateName);
          if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef,this.metadataReaderFactory) && !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {
            configCandidates.add(new BeanDefinitionHolder(beanDef,candidateName));
          }
        }
      }
      candidateNames=newCandidateNames;
    }
  }
 while (!configCandidates.isEmpty());
  if (singletonRegistry != null) {
    if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME,parser.getImportRegistry());
    }
  }
  if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
    ((CachingMetadataReaderFactory)this.metadataReaderFactory).clearCache();
  }
}
