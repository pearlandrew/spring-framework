{
  return Publishers.flatMap(inputStream,new Function<ByteBuffer,Publisher<? extends ByteBuffer>>(){
    int openBraces;
    int idx;
    int state;
    boolean insideString;
    ByteBuf in;
    Integer wrtIdx;
    @Override public Publisher<? extends ByteBuffer> apply(    ByteBuffer b){
      List<ByteBuffer> chunks=new ArrayList<>();
      if (in == null) {
        in=Unpooled.copiedBuffer(b);
        wrtIdx=in.writerIndex();
      }
 else {
        in=Unpooled.copiedBuffer(in,Unpooled.copiedBuffer(b));
        wrtIdx=in.writerIndex();
      }
      if (state == ST_CORRUPTED) {
        in.skipBytes(in.readableBytes());
        return Publishers.error(new IllegalStateException("Corrupted stream"));
      }
      if (wrtIdx > maxObjectLength) {
        in.skipBytes(in.readableBytes());
        reset();
        return Publishers.error(new IllegalStateException("object length exceeds " + maxObjectLength + ": "+ wrtIdx+ " bytes discarded"));
      }
      for (; idx < wrtIdx; idx++) {
        byte c=in.getByte(idx);
        if (state == ST_DECODING_NORMAL) {
          decodeByte(c,in,idx);
          if (openBraces == 0) {
            ByteBuf json=extractObject(in,in.readerIndex(),idx + 1 - in.readerIndex());
            if (json != null) {
              chunks.add(json.nioBuffer());
            }
            in.readerIndex(idx + 1);
            reset();
          }
        }
 else         if (state == ST_DECODING_ARRAY_STREAM) {
          decodeByte(c,in,idx);
          if (!insideString && (openBraces == 1 && c == ',' || openBraces == 0 && c == ']')) {
            for (int i=in.readerIndex(); Character.isWhitespace(in.getByte(i)); i++) {
              in.skipBytes(1);
            }
            int idxNoSpaces=idx - 1;
            while (idxNoSpaces >= in.readerIndex() && Character.isWhitespace(in.getByte(idxNoSpaces))) {
              idxNoSpaces--;
            }
            ByteBuf json=extractObject(in,in.readerIndex(),idxNoSpaces + 1 - in.readerIndex());
            if (json != null) {
              chunks.add(json.nioBuffer());
            }
            in.readerIndex(idx + 1);
            if (c == ']') {
              reset();
            }
          }
        }
 else         if (c == '{' || c == '[') {
          initDecoding(c,streamArrayElements);
          if (state == ST_DECODING_ARRAY_STREAM) {
            in.skipBytes(1);
          }
        }
 else         if (Character.isWhitespace(c)) {
          in.skipBytes(1);
        }
 else {
          state=ST_CORRUPTED;
          return Publishers.error(new IllegalStateException("invalid JSON received at byte position " + idx + ": "+ ByteBufUtil.hexDump(in)));
        }
      }
      if (in.readableBytes() == 0) {
        idx=0;
      }
      return Publishers.from(chunks);
    }
    /** 
 * Override this method if you want to filter the json objects/arrays that get passed through the pipeline.
 */
    @SuppressWarnings("UnusedParameters") protected ByteBuf extractObject(    ByteBuf buffer,    int index,    int length){
      return buffer.slice(index,length).retain();
    }
    private void decodeByte(    byte c,    ByteBuf in,    int idx){
      if ((c == '{' || c == '[') && !insideString) {
        openBraces++;
      }
 else       if ((c == '}' || c == ']') && !insideString) {
        openBraces--;
      }
 else       if (c == '"') {
        if (!insideString) {
          insideString=true;
        }
 else         if (in.getByte(idx - 1) != '\\') {
          insideString=false;
        }
      }
    }
    private void initDecoding(    byte openingBrace,    boolean streamArrayElements){
      openBraces=1;
      if (openingBrace == '[' && streamArrayElements) {
        state=ST_DECODING_ARRAY_STREAM;
      }
 else {
        state=ST_DECODING_NORMAL;
      }
    }
    private void reset(){
      insideString=false;
      state=ST_INIT;
      openBraces=0;
    }
  }
);
}
