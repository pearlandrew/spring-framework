{
  final List<SqlParameter> declaredReturnParameters=new ArrayList<SqlParameter>();
  final Map<String,SqlParameter> declaredParameters=new LinkedHashMap<String,SqlParameter>();
  boolean returnDeclared=false;
  List<String> outParameterNames=new ArrayList<String>();
  List<String> metaDataParameterNames=new ArrayList<String>();
  for (  CallParameterMetaData meta : metaDataProvider.getCallParameterMetaData()) {
    if (meta.getParameterType() != DatabaseMetaData.procedureColumnReturn) {
      metaDataParameterNames.add(meta.getParameterName().toLowerCase());
    }
  }
  for (  SqlParameter parameter : parameters) {
    if (parameter.isResultsParameter()) {
      declaredReturnParameters.add(parameter);
    }
 else {
      String parameterNameToMatch=this.metaDataProvider.parameterNameToUse(parameter.getName()).toLowerCase();
      declaredParameters.put(parameterNameToMatch,parameter);
      if (parameter instanceof SqlOutParameter) {
        outParameterNames.add(parameter.getName());
        if (this.isFunction() && !metaDataParameterNames.contains(parameterNameToMatch)) {
          if (!returnDeclared) {
            if (logger.isDebugEnabled()) {
              logger.debug("Using declared out parameter '" + parameter.getName() + "' for function return value");
            }
            this.setFunctionReturnName(parameter.getName());
            returnDeclared=true;
          }
        }
      }
    }
  }
  this.setOutParameterNames(outParameterNames);
  final List<SqlParameter> workParameters=new ArrayList<SqlParameter>();
  workParameters.addAll(declaredReturnParameters);
  if (!this.metaDataProvider.isProcedureColumnMetaDataUsed()) {
    workParameters.addAll(declaredParameters.values());
    return workParameters;
  }
  Map<String,String> limitedInParamNamesMap=new HashMap<String,String>(this.limitedInParameterNames.size());
  for (  String limitedParameterName : this.limitedInParameterNames) {
    limitedInParamNamesMap.put(this.metaDataProvider.parameterNameToUse(limitedParameterName).toLowerCase(),limitedParameterName);
  }
  for (  CallParameterMetaData meta : metaDataProvider.getCallParameterMetaData()) {
    String parNameToCheck=null;
    if (meta.getParameterName() != null) {
      parNameToCheck=this.metaDataProvider.parameterNameToUse(meta.getParameterName()).toLowerCase();
    }
    String parNameToUse=this.metaDataProvider.parameterNameToUse(meta.getParameterName());
    if (declaredParameters.containsKey(parNameToCheck) || (meta.getParameterType() == DatabaseMetaData.procedureColumnReturn && returnDeclared)) {
      SqlParameter parameter;
      if (meta.getParameterType() == DatabaseMetaData.procedureColumnReturn) {
        parameter=declaredParameters.get(this.getFunctionReturnName());
        if (parameter == null && this.getOutParameterNames().size() > 0) {
          parameter=declaredParameters.get(this.getOutParameterNames().get(0).toLowerCase());
        }
        if (parameter == null) {
          throw new InvalidDataAccessApiUsageException("Unable to locate declared parameter for function return value - " + " add an SqlOutParameter with name \"" + getFunctionReturnName() + "\"");
        }
 else {
          this.setFunctionReturnName(parameter.getName());
        }
      }
 else {
        parameter=declaredParameters.get(parNameToCheck);
      }
      if (parameter != null) {
        workParameters.add(parameter);
        if (logger.isDebugEnabled()) {
          logger.debug("Using declared parameter for: " + (parNameToUse == null ? getFunctionReturnName() : parNameToUse));
        }
      }
    }
 else {
      if (meta.getParameterType() == DatabaseMetaData.procedureColumnReturn) {
        if (!isFunction() && !isReturnValueRequired() && this.metaDataProvider.byPassReturnParameter(meta.getParameterName())) {
          if (logger.isDebugEnabled()) {
            logger.debug("Bypassing metadata return parameter for: " + meta.getParameterName());
          }
        }
 else {
          String returnNameToUse=(meta.getParameterName() == null || meta.getParameterName().length() < 1) ? this.getFunctionReturnName() : parNameToUse;
          workParameters.add(new SqlOutParameter(returnNameToUse,meta.getSqlType()));
          if (this.isFunction()) {
            this.setFunctionReturnName(returnNameToUse);
            outParameterNames.add(returnNameToUse);
          }
          if (logger.isDebugEnabled()) {
            logger.debug("Added metadata return parameter for: " + returnNameToUse);
          }
        }
      }
 else {
        if (meta.getParameterType() == DatabaseMetaData.procedureColumnOut) {
          workParameters.add(this.metaDataProvider.createDefaultOutParameter(parNameToUse,meta));
          outParameterNames.add(parNameToUse);
          if (logger.isDebugEnabled()) {
            logger.debug("Added metadata out parameter for: " + parNameToUse);
          }
        }
 else         if (meta.getParameterType() == DatabaseMetaData.procedureColumnInOut) {
          workParameters.add(this.metaDataProvider.createDefaultInOutParameter(parNameToUse,meta));
          outParameterNames.add(parNameToUse);
          if (logger.isDebugEnabled()) {
            logger.debug("Added metadata in out parameter for: " + parNameToUse);
          }
        }
 else {
          if (this.limitedInParameterNames.size() == 0 || limitedInParamNamesMap.containsKey(parNameToUse.toLowerCase())) {
            workParameters.add(this.metaDataProvider.createDefaultInParameter(parNameToUse,meta));
            if (logger.isDebugEnabled()) {
              logger.debug("Added metadata in parameter for: " + parNameToUse);
            }
          }
 else {
            if (logger.isDebugEnabled()) {
              logger.debug("Limited set of parameters " + limitedInParamNamesMap.keySet() + " skipped parameter for: "+ parNameToUse);
            }
          }
        }
      }
    }
  }
  return workParameters;
}
