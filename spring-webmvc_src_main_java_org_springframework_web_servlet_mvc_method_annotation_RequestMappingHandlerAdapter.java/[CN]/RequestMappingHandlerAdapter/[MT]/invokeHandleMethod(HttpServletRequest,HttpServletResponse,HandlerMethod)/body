{
  ServletWebRequest webRequest=new ServletWebRequest(request,response);
  WebDataBinderFactory binderFactory=getDataBinderFactory(handlerMethod);
  ModelFactory modelFactory=getModelFactory(handlerMethod,binderFactory);
  ServletInvocableHandlerMethod requestMappingMethod=createRequestMappingMethod(handlerMethod,binderFactory);
  ModelAndViewContainer mavContainer=new ModelAndViewContainer();
  mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
  modelFactory.initModel(webRequest,mavContainer,requestMappingMethod);
  mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);
  AsyncWebRequest asyncWebRequest=WebAsyncUtils.createAsyncWebRequest(request,response);
  asyncWebRequest.setTimeout(this.asyncRequestTimeout);
  final WebAsyncManager asyncManager=WebAsyncUtils.getAsyncManager(request);
  asyncManager.setTaskExecutor(this.taskExecutor);
  asyncManager.setAsyncWebRequest(asyncWebRequest);
  asyncManager.registerCallableInterceptor(this.callableInterceptors);
  asyncManager.registerDeferredResultInterceptor(this.deferredResultInterceptors);
  if (asyncManager.hasConcurrentResult()) {
    Object result=asyncManager.getConcurrentResult();
    mavContainer=(ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0];
    asyncManager.clearConcurrentResult();
    if (logger.isDebugEnabled()) {
      logger.debug("Found concurrent result value [" + result + "]");
    }
    requestMappingMethod=requestMappingMethod.wrapConcurrentResult(result);
  }
  requestMappingMethod.invokeAndHandle(webRequest,mavContainer);
  if (asyncManager.isConcurrentHandlingStarted()) {
    return null;
  }
  return getModelAndView(mavContainer,modelFactory,webRequest);
}
