{
  Map<String,Object> attributes=new HashMap<String,Object>(originalAttributes);
  Map<String,String> attributeAliasMap=getAttributeAliasMap(annotationType);
  for (  Method attributeMethod : getAttributeMethods(annotationType)) {
    String attributeName=attributeMethod.getName();
    Object attributeValue=attributes.get(attributeName);
    if (attributeValue == null) {
      String aliasName=attributeAliasMap.get(attributeName);
      if (aliasName != null) {
        Object aliasValue=attributes.get(aliasName);
        if (aliasValue != null) {
          attributeValue=aliasValue;
          attributes.put(attributeName,attributeValue);
        }
      }
    }
    if (attributeValue == null) {
      Object defaultValue=getDefaultValue(annotationType,attributeName);
      if (defaultValue != null) {
        attributeValue=defaultValue;
        attributes.put(attributeName,attributeValue);
      }
    }
    if (attributeValue == null) {
      throw new IllegalArgumentException(String.format("Attributes map [%s] returned null for required attribute [%s] defined by annotation type [%s].",attributes,attributeName,annotationType.getName()));
    }
    Class<?> requiredReturnType=attributeMethod.getReturnType();
    Class<? extends Object> actualReturnType=attributeValue.getClass();
    if (!ClassUtils.isAssignable(requiredReturnType,actualReturnType)) {
      boolean converted=false;
      if (Annotation.class.isAssignableFrom(requiredReturnType) && Map.class.isAssignableFrom(actualReturnType)) {
        Class<? extends Annotation> nestedAnnotationType=(Class<? extends Annotation>)requiredReturnType;
        Map<String,Object> map=(Map<String,Object>)attributeValue;
        attributes.put(attributeName,synthesizeAnnotation(map,nestedAnnotationType,null));
        converted=true;
      }
 else       if (requiredReturnType.isArray() && Annotation.class.isAssignableFrom(requiredReturnType.getComponentType()) && actualReturnType.isArray()&& Map.class.isAssignableFrom(actualReturnType.getComponentType())) {
        Class<? extends Annotation> nestedAnnotationType=(Class<? extends Annotation>)requiredReturnType.getComponentType();
        Map<String,Object>[] maps=(Map<String,Object>[])attributeValue;
        attributes.put(attributeName,synthesizeAnnotationArray(maps,nestedAnnotationType));
        converted=true;
      }
      if (!converted) {
        throw new IllegalArgumentException(String.format("Attributes map [%s] returned a value of type [%s] for attribute [%s], " + "but a value of type [%s] is required as defined by annotation type [%s].",attributes,actualReturnType.getName(),attributeName,requiredReturnType.getName(),annotationType.getName()));
      }
    }
  }
  return attributes;
}
