{
  super(propertyName,null,null);
  this.beanClass=beanClass;
  this.propertyEditorClass=propertyEditorClass;
  Method readMethodToUse=BridgeMethodResolver.findBridgedMethod(readMethod);
  Method writeMethodToUse=BridgeMethodResolver.findBridgedMethod(writeMethod);
  if (writeMethodToUse == null && readMethodToUse != null) {
    Method candidate=ClassUtils.getMethodIfAvailable(this.beanClass,"set" + StringUtils.capitalize(getName()),(Class<?>[])null);
    if (candidate != null && candidate.getParameterTypes().length == 1) {
      writeMethodToUse=candidate;
    }
  }
  this.readMethod=readMethodToUse;
  this.writeMethod=writeMethodToUse;
  if (this.writeMethod != null && this.readMethod == null) {
    Set<Method> ambiguousCandidates=new HashSet<Method>();
    for (    Method method : beanClass.getMethods()) {
      if (method.getName().equals(writeMethodToUse.getName()) && !method.equals(writeMethodToUse) && !method.isBridge()) {
        ambiguousCandidates.add(method);
      }
    }
    if (!ambiguousCandidates.isEmpty()) {
      this.ambiguousWriteMethods=ambiguousCandidates;
    }
  }
}
