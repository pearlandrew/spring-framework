{
  Map<CacheOperationContext,Object> cUpdates=new LinkedHashMap<CacheOperationContext,Object>(cacheables.size());
  boolean updateRequired=false;
  Object retVal=null;
  if (!cacheables.isEmpty()) {
    boolean log=logger.isTraceEnabled();
    boolean atLeastOnePassed=false;
    for (    CacheOperationContext context : cacheables) {
      if (context.isConditionPassing()) {
        atLeastOnePassed=true;
        Object key=context.generateKey();
        if (log) {
          logger.trace("Computed cache key " + key + " for operation "+ context.operation);
        }
        if (key == null) {
          throw new IllegalArgumentException("Null key returned for cache operation (maybe you are using named params on classes without debug info?) " + context.operation);
        }
        cUpdates.put(context,key);
        boolean localCacheHit=false;
        if (!updateRequired) {
          for (          Cache cache : context.getCaches()) {
            Cache.ValueWrapper wrapper=cache.get(key);
            if (wrapper != null) {
              retVal=wrapper.get();
              localCacheHit=true;
              break;
            }
          }
        }
        if (!localCacheHit) {
          updateRequired=true;
        }
      }
 else {
        if (log) {
          logger.trace("Cache condition failed on method " + context.method + " for operation "+ context.operation);
        }
      }
    }
    if (atLeastOnePassed) {
      return new CacheStatus(cUpdates,updateRequired,retVal);
    }
  }
  return null;
}
