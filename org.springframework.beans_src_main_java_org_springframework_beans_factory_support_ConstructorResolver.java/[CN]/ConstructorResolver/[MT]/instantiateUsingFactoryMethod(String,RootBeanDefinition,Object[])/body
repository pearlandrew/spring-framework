{
  BeanWrapperImpl bw=new BeanWrapperImpl();
  this.beanFactory.initBeanWrapper(bw);
  Object factoryBean;
  Class factoryClass;
  boolean isStatic;
  String factoryBeanName=mbd.getFactoryBeanName();
  if (factoryBeanName != null) {
    if (factoryBeanName.equals(beanName)) {
      throw new BeanDefinitionStoreException(mbd.getResourceDescription(),beanName,"factory-bean reference points back to the same bean definition");
    }
    factoryBean=this.beanFactory.getBean(factoryBeanName);
    if (factoryBean == null) {
      throw new BeanCreationException(mbd.getResourceDescription(),beanName,"factory-bean '" + factoryBeanName + "' returned null");
    }
    factoryClass=factoryBean.getClass();
    isStatic=false;
  }
 else {
    if (!mbd.hasBeanClass()) {
      throw new BeanDefinitionStoreException(mbd.getResourceDescription(),beanName,"bean definition declares neither a bean class nor a factory-bean reference");
    }
    factoryBean=null;
    factoryClass=mbd.getBeanClass();
    isStatic=true;
  }
  Method factoryMethodToUse=null;
  Object[] argsToUse=null;
  if (explicitArgs != null) {
    argsToUse=explicitArgs;
  }
 else {
    factoryMethodToUse=(Method)mbd.resolvedConstructorOrFactoryMethod;
    if (factoryMethodToUse != null) {
      argsToUse=mbd.resolvedConstructorArguments;
      if (argsToUse == null && mbd.preparedConstructorArguments != null) {
        argsToUse=resolvePreparedArguments(beanName,mbd,bw,factoryMethodToUse);
      }
    }
  }
  if (factoryMethodToUse == null || argsToUse == null) {
    factoryClass=ClassUtils.getUserClass(factoryClass);
    Method[] rawCandidates=(mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());
    List<Method> candidateSet=new ArrayList<Method>();
    for (    Method candidate : rawCandidates) {
      if (Modifier.isStatic(candidate.getModifiers()) == isStatic && candidate.getName().equals(mbd.getFactoryMethodName()) && mbd.isFactoryMethod(candidate)) {
        candidateSet.add(candidate);
      }
    }
    Method[] candidates=candidateSet.toArray(new Method[candidateSet.size()]);
    AutowireUtils.sortFactoryMethods(candidates);
    boolean autowiring=(mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
    int minTypeDiffWeight=Integer.MAX_VALUE;
    ConstructorArgumentValues resolvedValues=null;
    int minNrOfArgs;
    if (explicitArgs != null) {
      minNrOfArgs=explicitArgs.length;
    }
 else {
      ConstructorArgumentValues cargs=mbd.getConstructorArgumentValues();
      resolvedValues=new ConstructorArgumentValues();
      minNrOfArgs=resolveConstructorArguments(beanName,mbd,bw,cargs,resolvedValues);
    }
    List<Exception> causes=null;
    for (int i=0; i < candidates.length; i++) {
      Method candidate=candidates[i];
      Class[] paramTypes=candidate.getParameterTypes();
      if (paramTypes.length >= minNrOfArgs) {
        ArgumentsHolder args;
        if (resolvedValues != null) {
          try {
            String[] paramNames=null;
            ParameterNameDiscoverer pnd=this.beanFactory.getParameterNameDiscoverer();
            if (pnd != null) {
              paramNames=pnd.getParameterNames(candidate);
            }
            args=createArgumentArray(beanName,mbd,resolvedValues,bw,paramTypes,paramNames,candidate,autowiring);
          }
 catch (          UnsatisfiedDependencyException ex) {
            if (this.beanFactory.logger.isTraceEnabled()) {
              this.beanFactory.logger.trace("Ignoring factory method [" + candidate + "] of bean '"+ beanName+ "': "+ ex);
            }
            if (i == candidates.length - 1 && factoryMethodToUse == null) {
              if (causes != null) {
                for (                Exception cause : causes) {
                  this.beanFactory.onSuppressedException(cause);
                }
              }
              throw ex;
            }
 else {
              if (causes == null) {
                causes=new LinkedList<Exception>();
              }
              causes.add(ex);
              continue;
            }
          }
        }
 else {
          if (paramTypes.length != explicitArgs.length) {
            continue;
          }
          args=new ArgumentsHolder(explicitArgs);
        }
        int typeDiffWeight=(mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));
        if (typeDiffWeight < minTypeDiffWeight) {
          factoryMethodToUse=candidate;
          argsToUse=args.arguments;
          minTypeDiffWeight=typeDiffWeight;
        }
 else         if (typeDiffWeight < Integer.MAX_VALUE && typeDiffWeight == minTypeDiffWeight && !mbd.isLenientConstructorResolution()) {
          throw new BeanCreationException(mbd.getResourceDescription(),beanName,"Ambiguous factory method matches found in bean '" + beanName + "' "+ "(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)");
        }
      }
    }
    if (factoryMethodToUse == null) {
      throw new BeanCreationException(mbd.getResourceDescription(),beanName,"No matching factory method found: " + (mbd.getFactoryBeanName() != null ? "factory bean '" + mbd.getFactoryBeanName() + "'; " : "") + "factory method '"+ mbd.getFactoryMethodName()+ "'");
    }
    if (void.class.equals(factoryMethodToUse.getReturnType())) {
      throw new BeanCreationException(mbd.getResourceDescription(),beanName,"Invalid factory method '" + mbd.getFactoryMethodName() + "': needs to have a non-void return type!");
    }
    if (explicitArgs == null) {
      mbd.resolvedConstructorOrFactoryMethod=factoryMethodToUse;
    }
  }
  try {
    Object beanInstance=this.beanFactory.getInstantiationStrategy().instantiate(mbd,beanName,this.beanFactory,factoryBean,factoryMethodToUse,argsToUse);
    if (beanInstance == null) {
      return null;
    }
    bw.setWrappedInstance(beanInstance);
    return bw;
  }
 catch (  Throwable ex) {
    throw new BeanCreationException(mbd.getResourceDescription(),beanName,"Instantiation of bean failed",ex);
  }
}
