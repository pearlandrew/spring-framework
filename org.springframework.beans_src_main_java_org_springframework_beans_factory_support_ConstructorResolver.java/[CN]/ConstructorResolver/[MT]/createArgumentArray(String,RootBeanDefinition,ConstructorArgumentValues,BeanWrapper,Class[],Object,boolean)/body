{
  String methodType=(methodOrCtor instanceof Constructor ? "constructor" : "factory method");
  TypeConverter converter=(this.typeConverter != null ? this.typeConverter : bw);
  ArgumentsHolder args=new ArgumentsHolder(paramTypes.length);
  Set<ConstructorArgumentValues.ValueHolder> usedValueHolders=new HashSet<ConstructorArgumentValues.ValueHolder>(paramTypes.length);
  Set<String> autowiredBeanNames=new LinkedHashSet<String>(4);
  boolean resolveNecessary=false;
  for (int paramIndex=0; paramIndex < paramTypes.length; paramIndex++) {
    Class paramType=paramTypes[paramIndex];
    ConstructorArgumentValues.ValueHolder valueHolder=resolvedValues.getArgumentValue(paramIndex,paramType,usedValueHolders);
    if (valueHolder == null && !autowiring) {
      valueHolder=resolvedValues.getGenericArgumentValue(null,usedValueHolders);
    }
    if (valueHolder != null) {
      usedValueHolders.add(valueHolder);
      args.rawArguments[paramIndex]=valueHolder.getValue();
      if (valueHolder.isConverted()) {
        Object convertedValue=valueHolder.getConvertedValue();
        args.arguments[paramIndex]=convertedValue;
        args.preparedArguments[paramIndex]=convertedValue;
      }
 else {
        try {
          Object originalValue=valueHolder.getValue();
          Object convertedValue=converter.convertIfNecessary(originalValue,paramType,MethodParameter.forMethodOrConstructor(methodOrCtor,paramIndex));
          args.arguments[paramIndex]=convertedValue;
          ConstructorArgumentValues.ValueHolder sourceHolder=(ConstructorArgumentValues.ValueHolder)valueHolder.getSource();
          Object sourceValue=sourceHolder.getValue();
          if (originalValue == sourceValue || sourceValue instanceof TypedStringValue) {
            sourceHolder.setConvertedValue(convertedValue);
            args.preparedArguments[paramIndex]=convertedValue;
          }
 else {
            resolveNecessary=true;
            args.preparedArguments[paramIndex]=sourceValue;
          }
        }
 catch (        TypeMismatchException ex) {
          throw new UnsatisfiedDependencyException(mbd.getResourceDescription(),beanName,paramIndex,paramType,"Could not convert " + methodType + " argument value of type ["+ ObjectUtils.nullSafeClassName(valueHolder.getValue())+ "] to required type ["+ paramType.getName()+ "]: "+ ex.getMessage());
        }
      }
    }
 else {
      if (!autowiring) {
        throw new UnsatisfiedDependencyException(mbd.getResourceDescription(),beanName,paramIndex,paramType,"Ambiguous " + methodType + " argument types - "+ "did you specify the correct bean references as "+ methodType+ " arguments?");
      }
      try {
        MethodParameter param=MethodParameter.forMethodOrConstructor(methodOrCtor,paramIndex);
        Object autowiredArgument=resolveAutowiredArgument(param,beanName,autowiredBeanNames,converter);
        args.rawArguments[paramIndex]=autowiredArgument;
        args.arguments[paramIndex]=autowiredArgument;
        args.preparedArguments[paramIndex]=new AutowiredArgumentMarker();
        resolveNecessary=true;
      }
 catch (      BeansException ex) {
        throw new UnsatisfiedDependencyException(mbd.getResourceDescription(),beanName,paramIndex,paramType,ex);
      }
    }
  }
  for (  String autowiredBeanName : autowiredBeanNames) {
    this.beanFactory.registerDependentBean(autowiredBeanName,beanName);
    if (this.beanFactory.logger.isDebugEnabled()) {
      this.beanFactory.logger.debug("Autowiring by type from bean name '" + beanName + "' via "+ methodType+ " to bean named '"+ autowiredBeanName+ "'");
    }
  }
  if (resolveNecessary) {
    mbd.preparedConstructorArguments=args.preparedArguments;
  }
 else {
    mbd.resolvedConstructorArguments=args.arguments;
  }
  mbd.constructorArgumentsResolved=true;
  return args;
}
