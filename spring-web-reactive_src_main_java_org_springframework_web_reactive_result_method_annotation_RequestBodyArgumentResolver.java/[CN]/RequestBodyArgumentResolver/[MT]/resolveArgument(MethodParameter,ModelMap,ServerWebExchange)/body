{
  ResolvableType type=ResolvableType.forMethodParameter(parameter);
  boolean isAsyncType=isAsyncType(type);
  boolean isStreamableType=isStreamableType(type);
  ResolvableType elementType=(isStreamableType || isAsyncType ? type.getGeneric(0) : type);
  MediaType mediaType=exchange.getRequest().getHeaders().getContentType();
  if (mediaType == null) {
    mediaType=MediaType.APPLICATION_OCTET_STREAM;
  }
  for (  HttpMessageConverter<?> converter : getMessageConverters()) {
    if (converter.canRead(elementType,mediaType)) {
      if (isStreamableType) {
        Publisher<?> elements=converter.read(elementType,exchange.getRequest());
        if (this.validator != null) {
          elements=applyValidationIfApplicable(elements,parameter);
        }
        if (Flux.class.equals(type.getRawClass())) {
          return Mono.just(elements);
        }
 else         if (isAsyncType && this.conversionService.canConvert(Flux.class,type.getRawClass())) {
          return Mono.just(this.conversionService.convert(elements,type.getRawClass()));
        }
      }
 else {
        Mono<?> element=converter.readOne(elementType,exchange.getRequest());
        if (this.validator != null) {
          element=Mono.from(applyValidationIfApplicable(element,parameter));
        }
        if (Mono.class.equals(type.getRawClass())) {
          return Mono.just(element);
        }
 else         if (isAsyncType && this.conversionService.canConvert(Mono.class,type.getRawClass())) {
          return Mono.just(this.conversionService.convert(element,type.getRawClass()));
        }
 else {
          return (Mono<Object>)element;
        }
      }
    }
  }
  return Mono.error(new UnsupportedMediaTypeStatusException(mediaType,this.supportedMediaTypes));
}
