{
  try {
    TypeConverter typeConverter=context.getTypeConverter();
    Class<?> type=context.getTypeLocator().findType(typename);
    Constructor[] ctors=type.getConstructors();
    Constructor closeMatch=null;
    int[] argsToConvert=null;
    Constructor matchRequiringConversion=null;
    for (    Constructor ctor : ctors) {
      ReflectionHelper.ArgumentsMatchInfo matchInfo=null;
      if (ctor.isVarArgs() && argumentTypes.length >= (ctor.getParameterTypes().length - 1)) {
        matchInfo=ReflectionHelper.compareArgumentsVarargs(ctor.getParameterTypes(),argumentTypes,typeConverter);
      }
 else       if (ctor.getParameterTypes().length == argumentTypes.length) {
        matchInfo=ReflectionHelper.compareArguments(ctor.getParameterTypes(),argumentTypes,typeConverter);
      }
      if (matchInfo != null) {
        if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.EXACT) {
          return new ReflectiveConstructorExecutor(ctor,null);
        }
 else         if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.CLOSE) {
          closeMatch=ctor;
        }
 else         if (matchInfo.kind == ReflectionHelper.ArgsMatchKind.REQUIRES_CONVERSION) {
          argsToConvert=matchInfo.argsRequiringConversion;
          matchRequiringConversion=ctor;
        }
      }
    }
    if (closeMatch != null) {
      return new ReflectiveConstructorExecutor(closeMatch,null);
    }
 else     if (matchRequiringConversion != null) {
      return new ReflectiveConstructorExecutor(matchRequiringConversion,argsToConvert);
    }
 else {
      return null;
    }
  }
 catch (  EvaluationException ex) {
    throw new AccessException("Failed to resolve constructor",ex);
  }
}
