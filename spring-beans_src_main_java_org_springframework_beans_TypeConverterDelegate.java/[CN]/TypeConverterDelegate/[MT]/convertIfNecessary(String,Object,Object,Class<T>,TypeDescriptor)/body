{
  Object convertedValue=newValue;
  PropertyEditor editor=this.propertyEditorRegistry.findCustomEditor(requiredType,propertyName);
  ConversionFailedException firstAttemptEx=null;
  ConversionService conversionService=this.propertyEditorRegistry.getConversionService();
  if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {
    TypeDescriptor sourceTypeDesc=TypeDescriptor.forObject(newValue);
    TypeDescriptor targetTypeDesc=typeDescriptor;
    if (conversionService.canConvert(sourceTypeDesc,targetTypeDesc)) {
      try {
        return (T)conversionService.convert(convertedValue,sourceTypeDesc,targetTypeDesc);
      }
 catch (      ConversionFailedException ex) {
        firstAttemptEx=ex;
      }
    }
  }
  if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType,convertedValue))) {
    if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {
      TypeDescriptor elementType=typeDescriptor.getElementTypeDescriptor();
      if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {
        convertedValue=StringUtils.commaDelimitedListToStringArray((String)convertedValue);
      }
    }
    if (editor == null) {
      editor=findDefaultEditor(requiredType);
    }
    convertedValue=doConvertValue(oldValue,convertedValue,requiredType,editor);
  }
  boolean standardConversion=false;
  if (requiredType != null) {
    if (convertedValue != null) {
      if (Object.class.equals(requiredType)) {
        return (T)convertedValue;
      }
      if (requiredType.isArray()) {
        if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {
          convertedValue=StringUtils.commaDelimitedListToStringArray((String)convertedValue);
        }
        return (T)convertToTypedArray(convertedValue,propertyName,requiredType.getComponentType());
      }
 else       if (convertedValue instanceof Collection) {
        convertedValue=convertToTypedCollection((Collection<?>)convertedValue,propertyName,requiredType,typeDescriptor);
        standardConversion=true;
      }
 else       if (convertedValue instanceof Map) {
        convertedValue=convertToTypedMap((Map<?,?>)convertedValue,propertyName,requiredType,typeDescriptor);
        standardConversion=true;
      }
      if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {
        convertedValue=Array.get(convertedValue,0);
        standardConversion=true;
      }
      if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {
        return (T)convertedValue.toString();
      }
 else       if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {
        if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {
          try {
            Constructor<T> strCtor=requiredType.getConstructor(String.class);
            return BeanUtils.instantiateClass(strCtor,convertedValue);
          }
 catch (          NoSuchMethodException ex) {
            if (logger.isTraceEnabled()) {
              logger.trace("No String constructor found on type [" + requiredType.getName() + "]",ex);
            }
          }
catch (          Exception ex) {
            if (logger.isDebugEnabled()) {
              logger.debug("Construction via String failed for type [" + requiredType.getName() + "]",ex);
            }
          }
        }
        String trimmedValue=((String)convertedValue).trim();
        if (requiredType.isEnum() && "".equals(trimmedValue)) {
          return null;
        }
        convertedValue=attemptToConvertStringToEnum(requiredType,trimmedValue,convertedValue);
        standardConversion=true;
      }
    }
 else     if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {
      convertedValue=javaUtilOptionalEmpty;
    }
    if (!ClassUtils.isAssignableValue(requiredType,convertedValue)) {
      if (firstAttemptEx != null) {
        throw firstAttemptEx;
      }
      StringBuilder msg=new StringBuilder();
      msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue));
      msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]");
      if (propertyName != null) {
        msg.append(" for property '").append(propertyName).append("'");
      }
      if (editor != null) {
        msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]");
        throw new IllegalArgumentException(msg.toString());
      }
 else {
        msg.append(": no matching editors or conversion strategy found");
        throw new IllegalStateException(msg.toString());
      }
    }
  }
  if (firstAttemptEx != null) {
    if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {
      throw firstAttemptEx;
    }
    logger.debug("Original ConversionService attempt failed - ignored since " + "PropertyEditor based conversion eventually succeeded",firstAttemptEx);
  }
  return (T)convertedValue;
}
