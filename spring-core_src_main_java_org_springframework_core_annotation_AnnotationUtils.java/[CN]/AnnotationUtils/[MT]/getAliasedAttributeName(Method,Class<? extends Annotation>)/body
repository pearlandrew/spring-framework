{
  Class<?> declaringClass=attribute.getDeclaringClass();
  Assert.isTrue(declaringClass.isAnnotation(),"attribute method must be from an annotation");
  Assert.isTrue(!Annotation.class.equals(targetAnnotationType),"targetAnnotationType must not be java.lang.annotation.Annotation");
  String attributeName=attribute.getName();
  AliasFor aliasFor=attribute.getAnnotation(AliasFor.class);
  if (aliasFor == null) {
    return null;
  }
  Class<? extends Annotation> sourceAnnotationType=(Class<? extends Annotation>)declaringClass;
  Class<? extends Annotation> aliasedAnnotationType=aliasFor.annotation();
  boolean searchWithinSameAnnotation=(targetAnnotationType == null);
  boolean sameTargetDeclared=(sourceAnnotationType.equals(aliasedAnnotationType) || Annotation.class.equals(aliasedAnnotationType));
  if (!searchWithinSameAnnotation && !targetAnnotationType.equals(aliasedAnnotationType)) {
    return null;
  }
  String aliasedAttributeName=getAliasedAttributeName(aliasFor,attribute);
  if (!StringUtils.hasText(aliasedAttributeName)) {
    String msg=String.format("@AliasFor declaration on attribute [%s] in annotation [%s] is missing required 'attribute' value.",attributeName,sourceAnnotationType.getName());
    throw new AnnotationConfigurationException(msg);
  }
  if (!sameTargetDeclared) {
    if (findAnnotation(sourceAnnotationType,aliasedAnnotationType) == null) {
      String msg=String.format("@AliasFor declaration on attribute [%s] in annotation [%s] declares " + "an alias for attribute [%s] in meta-annotation [%s] which is not meta-present.",attributeName,sourceAnnotationType.getName(),aliasedAttributeName,aliasedAnnotationType.getName());
      throw new AnnotationConfigurationException(msg);
    }
  }
 else {
    aliasedAnnotationType=sourceAnnotationType;
  }
  if (searchWithinSameAnnotation && !sameTargetDeclared) {
    return null;
  }
  Method aliasedAttribute;
  try {
    aliasedAttribute=aliasedAnnotationType.getDeclaredMethod(aliasedAttributeName);
  }
 catch (  NoSuchMethodException ex) {
    String msg=String.format("Attribute [%s] in annotation [%s] is declared as an @AliasFor nonexistent attribute [%s] in annotation [%s].",attributeName,sourceAnnotationType.getName(),aliasedAttributeName,aliasedAnnotationType.getName());
    throw new AnnotationConfigurationException(msg,ex);
  }
  if (sameTargetDeclared) {
    AliasFor mirrorAliasFor=aliasedAttribute.getAnnotation(AliasFor.class);
    if (mirrorAliasFor == null) {
      String msg=String.format("Attribute [%s] in annotation [%s] must be declared as an @AliasFor [%s].",aliasedAttributeName,sourceAnnotationType.getName(),attributeName);
      throw new AnnotationConfigurationException(msg);
    }
    String mirrorAliasedAttributeName=getAliasedAttributeName(mirrorAliasFor,aliasedAttribute);
    if (!attributeName.equals(mirrorAliasedAttributeName)) {
      String msg=String.format("Attribute [%s] in annotation [%s] must be declared as an @AliasFor [%s], not [%s].",aliasedAttributeName,sourceAnnotationType.getName(),attributeName,mirrorAliasedAttributeName);
      throw new AnnotationConfigurationException(msg);
    }
  }
  Class<?> returnType=attribute.getReturnType();
  Class<?> aliasedReturnType=aliasedAttribute.getReturnType();
  if (!returnType.equals(aliasedReturnType)) {
    String msg=String.format("Misconfigured aliases: attribute [%s] in annotation [%s] " + "and attribute [%s] in annotation [%s] must declare the same return type.",attributeName,sourceAnnotationType.getName(),aliasedAttributeName,aliasedAnnotationType.getName());
    throw new AnnotationConfigurationException(msg);
  }
  if (sameTargetDeclared) {
    Object defaultValue=attribute.getDefaultValue();
    Object aliasedDefaultValue=aliasedAttribute.getDefaultValue();
    if ((defaultValue == null) || (aliasedDefaultValue == null)) {
      String msg=String.format("Misconfigured aliases: attribute [%s] in annotation [%s] " + "and attribute [%s] in annotation [%s] must declare default values.",attributeName,sourceAnnotationType.getName(),aliasedAttributeName,aliasedAnnotationType.getName());
      throw new AnnotationConfigurationException(msg);
    }
    if (!ObjectUtils.nullSafeEquals(defaultValue,aliasedDefaultValue)) {
      String msg=String.format("Misconfigured aliases: attribute [%s] in annotation [%s] " + "and attribute [%s] in annotation [%s] must declare the same default value.",attributeName,sourceAnnotationType.getName(),aliasedAttributeName,aliasedAnnotationType.getName());
      throw new AnnotationConfigurationException(msg);
    }
  }
  return aliasedAttributeName;
}
