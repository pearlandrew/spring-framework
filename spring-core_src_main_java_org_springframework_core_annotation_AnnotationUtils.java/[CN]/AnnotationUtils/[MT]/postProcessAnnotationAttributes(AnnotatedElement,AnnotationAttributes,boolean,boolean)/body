{
  if (attributes == null) {
    return;
  }
  Class<? extends Annotation> annotationType=attributes.annotationType();
  Set<String> valuesAlreadyReplaced=new HashSet<String>();
  Map<String,List<String>> aliasMap=getAttributeAliasMap(annotationType);
  for (  String attributeName : aliasMap.keySet()) {
    if (valuesAlreadyReplaced.contains(attributeName)) {
      continue;
    }
    Object value=attributes.get(attributeName);
    boolean valuePresent=(value != null && value != DEFAULT_VALUE_PLACEHOLDER);
    for (    String aliasedAttributeName : aliasMap.get(attributeName)) {
      if (valuesAlreadyReplaced.contains(aliasedAttributeName)) {
        continue;
      }
      Object aliasedValue=attributes.get(aliasedAttributeName);
      boolean aliasPresent=(aliasedValue != null && aliasedValue != DEFAULT_VALUE_PLACEHOLDER);
      if (valuePresent || aliasPresent) {
        if (valuePresent && aliasPresent) {
          if (!ObjectUtils.nullSafeEquals(value,aliasedValue)) {
            String elementAsString=(element == null ? "unknown element" : element.toString());
            String msg=String.format("In AnnotationAttributes for annotation [%s] declared on [%s], " + "attribute [%s] and its alias [%s] are declared with values of [%s] and [%s], " + "but only one declaration is permitted.",annotationType.getName(),elementAsString,attributeName,aliasedAttributeName,ObjectUtils.nullSafeToString(value),ObjectUtils.nullSafeToString(aliasedValue));
            throw new AnnotationConfigurationException(msg);
          }
        }
 else         if (aliasPresent) {
          attributes.put(attributeName,adaptValue(element,aliasedValue,classValuesAsString,nestedAnnotationsAsMap));
          valuesAlreadyReplaced.add(attributeName);
        }
 else {
          attributes.put(aliasedAttributeName,adaptValue(element,value,classValuesAsString,nestedAnnotationsAsMap));
          valuesAlreadyReplaced.add(aliasedAttributeName);
        }
      }
    }
  }
  for (  String attributeName : attributes.keySet()) {
    if (valuesAlreadyReplaced.contains(attributeName)) {
      continue;
    }
    Object value=attributes.get(attributeName);
    if (value == DEFAULT_VALUE_PLACEHOLDER) {
      attributes.put(attributeName,adaptValue(element,getDefaultValue(annotationType,attributeName),classValuesAsString,nestedAnnotationsAsMap));
    }
  }
}
