{
  Object source=context.extractSource(element);
  CompositeComponentDefinition compDefinition=new CompositeComponentDefinition(element.getTagName(),source);
  context.pushContainingComponent(compDefinition);
  String orderAttribute=element.getAttribute("order");
  int order=orderAttribute.isEmpty() ? DEFAULT_MAPPING_ORDER : Integer.valueOf(orderAttribute);
  ManagedMap<String,Object> urlMap=new ManagedMap<String,Object>();
  urlMap.setSource(source);
  RootBeanDefinition handlerMappingDef=new RootBeanDefinition(SimpleUrlHandlerMapping.class);
  handlerMappingDef.getPropertyValues().add("order",order);
  handlerMappingDef.getPropertyValues().add("urlMap",urlMap);
  registerBeanDef(handlerMappingDef,context,source);
  Element channelElem=DomUtils.getChildElementByTagName(element,"client-inbound-channel");
  RuntimeBeanReference inChannel=getMessageChannel("clientInboundChannel",channelElem,context,source);
  channelElem=DomUtils.getChildElementByTagName(element,"client-outbound-channel");
  RuntimeBeanReference outChannel=getMessageChannel("clientOutboundChannel",channelElem,context,source);
  RootBeanDefinition registryBeanDef=new RootBeanDefinition(DefaultUserSessionRegistry.class);
  String registryBeanName=registerBeanDef(registryBeanDef,context,source);
  RuntimeBeanReference sessionRegistry=new RuntimeBeanReference(registryBeanName);
  RuntimeBeanReference subProtoHandler=registerSubProtoHandler(element,inChannel,outChannel,sessionRegistry,context,source);
  for (  Element endpointElem : DomUtils.getChildElementsByTagName(element,"stomp-endpoint")) {
    RuntimeBeanReference requestHandler=registerRequestHandler(endpointElem,subProtoHandler,context,source);
    String pathAttribute=endpointElem.getAttribute("path");
    Assert.state(StringUtils.hasText(pathAttribute),"Invalid <stomp-endpoint> (no path mapping)");
    List<String> paths=Arrays.asList(StringUtils.tokenizeToStringArray(pathAttribute,","));
    for (    String path : paths) {
      path=path.trim();
      Assert.state(StringUtils.hasText(path),"Invalid <stomp-endpoint> path attribute: " + pathAttribute);
      if (DomUtils.getChildElementByTagName(endpointElem,"sockjs") != null) {
        path=path.endsWith("/") ? path + "**" : path + "/**";
      }
      urlMap.put(path,requestHandler);
    }
  }
  channelElem=DomUtils.getChildElementByTagName(element,"broker-channel");
  RuntimeBeanReference brokerChannel=getMessageChannel("brokerChannel",channelElem,context,source);
  RootBeanDefinition broker=registerMessageBroker(element,inChannel,outChannel,brokerChannel,context,source);
  RuntimeBeanReference converter=registerMessageConverter(element,context,source);
  RuntimeBeanReference template=registerMessagingTemplate(element,brokerChannel,converter,context,source);
  registerAnnotationMethodMessageHandler(element,inChannel,outChannel,converter,template,context,source);
  RuntimeBeanReference resolver=registerUserDestinationResolver(element,sessionRegistry,context,source);
  registerUserDestinationMessageHandler(inChannel,brokerChannel,resolver,context,source);
  Map<String,Object> scopeMap=Collections.<String,Object>singletonMap("websocket",new SimpSessionScope());
  RootBeanDefinition scopeConfigurer=new RootBeanDefinition(CustomScopeConfigurer.class);
  scopeConfigurer.getPropertyValues().add("scopes",scopeMap);
  registerBeanDefByName("webSocketScopeConfigurer",scopeConfigurer,context,source);
  registerWebSocketMessageBrokerStats(broker,inChannel,outChannel,context,source);
  context.popAndRegisterContainingComponent();
  return null;
}
