{
  Object source=parserCxt.extractSource(element);
  CompositeComponentDefinition compDefinition=new CompositeComponentDefinition(element.getTagName(),source);
  parserCxt.pushContainingComponent(compDefinition);
  String orderAttribute=element.getAttribute("order");
  int order=orderAttribute.isEmpty() ? DEFAULT_MAPPING_ORDER : Integer.valueOf(orderAttribute);
  ManagedMap<String,Object> urlMap=new ManagedMap<String,Object>();
  urlMap.setSource(source);
  RootBeanDefinition handlerMappingDef=new RootBeanDefinition(SimpleUrlHandlerMapping.class);
  handlerMappingDef.getPropertyValues().add("order",order);
  handlerMappingDef.getPropertyValues().add("urlMap",urlMap);
  String beanName="clientInboundChannel";
  Element channelElem=DomUtils.getChildElementByTagName(element,"client-inbound-channel");
  RuntimeBeanReference clientInChannel=getMessageChannel(beanName,channelElem,parserCxt,source);
  beanName="clientOutboundChannel";
  channelElem=DomUtils.getChildElementByTagName(element,"client-outbound-channel");
  RuntimeBeanReference clientOutChannel=getMessageChannel(beanName,channelElem,parserCxt,source);
  RootBeanDefinition beanDef=new RootBeanDefinition(DefaultUserSessionRegistry.class);
  beanName=registerBeanDef(beanDef,parserCxt,source);
  RuntimeBeanReference userSessionRegistry=new RuntimeBeanReference(beanName);
  String frameBufferSizeAttribute=element.getAttribute("message-buffer-size");
  Integer messageBufferSizeLimit=frameBufferSizeAttribute.isEmpty() ? null : Integer.parseInt(frameBufferSizeAttribute);
  RuntimeBeanReference subProtocolWsHandler=registerSubProtocolWebSocketHandler(clientInChannel,clientOutChannel,userSessionRegistry,messageBufferSizeLimit,parserCxt,source);
  for (  Element stompEndpointElem : DomUtils.getChildElementsByTagName(element,"stomp-endpoint")) {
    RuntimeBeanReference httpRequestHandler=registerHttpRequestHandler(stompEndpointElem,subProtocolWsHandler,parserCxt,source);
    String pathAttribute=stompEndpointElem.getAttribute("path");
    Assert.state(StringUtils.hasText(pathAttribute),"Invalid <stomp-endpoint> (no path mapping)");
    List<String> paths=Arrays.asList(StringUtils.tokenizeToStringArray(pathAttribute,","));
    for (    String path : paths) {
      path=path.trim();
      Assert.state(StringUtils.hasText(path),"Invalid <stomp-endpoint> path attribute: " + pathAttribute);
      if (DomUtils.getChildElementByTagName(stompEndpointElem,"sockjs") != null) {
        path=path.endsWith("/") ? path + "**" : path + "/**";
      }
      urlMap.put(path,httpRequestHandler);
    }
  }
  registerBeanDef(handlerMappingDef,parserCxt,source);
  beanName="brokerChannel";
  channelElem=DomUtils.getChildElementByTagName(element,"broker-channel");
  RuntimeBeanReference brokerChannel=getMessageChannel(beanName,channelElem,parserCxt,source);
  registerMessageBroker(element,clientInChannel,clientOutChannel,brokerChannel,parserCxt,source);
  RuntimeBeanReference messageConverter=registerBrokerMessageConverter(element,parserCxt,source);
  RuntimeBeanReference messagingTemplate=registerBrokerMessagingTemplate(element,brokerChannel,messageConverter,parserCxt,source);
  registerAnnotationMethodMessageHandler(element,clientInChannel,clientOutChannel,messageConverter,messagingTemplate,parserCxt,source);
  RuntimeBeanReference userDestinationResolver=registerUserDestinationResolver(element,userSessionRegistry,parserCxt,source);
  registerUserDestinationMessageHandler(clientInChannel,clientOutChannel,brokerChannel,userDestinationResolver,parserCxt,source);
  parserCxt.popAndRegisterContainingComponent();
  return null;
}
