{
  final Class<?> handlerType=handler.getClass();
  final Class<? extends Throwable> thrownExceptionType=thrownException.getClass();
  Method handlerMethod=null;
  Map<Class<? extends Throwable>,Method> handlers=exceptionHandlerCache.get(handlerType);
  if (handlers != null) {
    handlerMethod=handlers.get(thrownExceptionType);
    if (handlerMethod != null) {
      return (handlerMethod == NO_METHOD_FOUND ? null : handlerMethod);
    }
  }
 else {
    handlers=new ConcurrentHashMap<Class<? extends Throwable>,Method>();
    exceptionHandlerCache.put(handlerType,handlers);
  }
  final Map<Class<? extends Throwable>,Method> matchedHandlers=new HashMap<Class<? extends Throwable>,Method>();
  ReflectionUtils.doWithMethods(handlerType,new ReflectionUtils.MethodCallback(){
    public void doWith(    Method method){
      method=ClassUtils.getMostSpecificMethod(method,handlerType);
      List<Class<? extends Throwable>> handledExceptions=getHandledExceptions(method);
      for (      Class<? extends Throwable> handledException : handledExceptions) {
        if (handledException.isAssignableFrom(thrownExceptionType)) {
          if (!matchedHandlers.containsKey(handledException)) {
            matchedHandlers.put(handledException,method);
          }
 else {
            Method oldMappedMethod=matchedHandlers.get(handledException);
            if (!oldMappedMethod.equals(method)) {
              throw new IllegalStateException("Ambiguous exception handler mapped for " + handledException + "]: {"+ oldMappedMethod+ ", "+ method+ "}.");
            }
          }
        }
      }
    }
  }
);
  handlerMethod=getBestMatchingMethod(matchedHandlers,thrownException);
  handlers.put(thrownExceptionType,(handlerMethod == null ? NO_METHOD_FOUND : handlerMethod));
  return handlerMethod;
}
