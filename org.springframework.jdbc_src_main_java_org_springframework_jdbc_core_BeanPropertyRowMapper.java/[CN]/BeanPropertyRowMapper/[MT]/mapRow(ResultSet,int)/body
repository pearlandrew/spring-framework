{
  Assert.state(this.mappedClass != null,"Mapped class was not specified");
  T mappedObject=BeanUtils.instantiate(this.mappedClass);
  BeanWrapper bw=PropertyAccessorFactory.forBeanPropertyAccess(mappedObject);
  initBeanWrapper(bw);
  ResultSetMetaData rsmd=rs.getMetaData();
  int columnCount=rsmd.getColumnCount();
  Set<String> populatedProperties=(isCheckFullyPopulated() ? new HashSet<String>() : null);
  for (int index=1; index <= columnCount; index++) {
    String column=JdbcUtils.lookupColumnName(rsmd,index).toLowerCase();
    PropertyDescriptor pd=this.mappedFields.get(column);
    if (pd != null) {
      try {
        Object value=getColumnValue(rs,index,pd);
        if (logger.isDebugEnabled() && rowNumber == 0) {
          logger.debug("Mapping column '" + column + "' to property '"+ pd.getName()+ "' of type "+ pd.getPropertyType());
        }
        try {
          bw.setPropertyValue(pd.getName(),value);
        }
 catch (        TypeMismatchException e) {
          if (value == null && primitivesDefaultedForNullValue) {
            logger.debug("Intercepted TypeMismatchException for row " + rowNumber + " and column '"+ column+ "' with value "+ value+ " when setting property '"+ pd.getName()+ "' of type "+ pd.getPropertyType()+ " on object: "+ mappedObject);
          }
 else {
            throw e;
          }
        }
        if (populatedProperties != null) {
          populatedProperties.add(pd.getName());
        }
      }
 catch (      NotWritablePropertyException ex) {
        throw new DataRetrievalFailureException("Unable to map column " + column + " to property "+ pd.getName(),ex);
      }
    }
  }
  if (populatedProperties != null && !populatedProperties.equals(this.mappedProperties)) {
    throw new InvalidDataAccessApiUsageException("Given ResultSet does not contain all fields " + "necessary to populate object of class [" + this.mappedClass + "]: "+ this.mappedProperties);
  }
  return mappedObject;
}
