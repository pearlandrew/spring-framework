{
  Assert.notNull(sourceClass,"The sourceType to convert from is required");
  Assert.notNull(targetType,"The targetType to convert to is required");
  if (targetType.getType() == null) {
    return NoOpConversionExecutor.INSTANCE;
  }
  TypeDescriptor sourceType=TypeDescriptor.valueOf(sourceClass);
  if (sourceType.isArray()) {
    if (targetType.isArray()) {
      return new ArrayToArray(sourceType,targetType,this);
    }
 else     if (targetType.isCollection()) {
      if (targetType.isAbstractClass()) {
        throw new IllegalArgumentException("Conversion target class [" + targetType.getName() + "] is invalid; cannot convert to abstract collection types. "+ "Request an interface or a concrete implementation instead!");
      }
      return new ArrayToCollection(sourceType,targetType,this);
    }
 else     if (targetType.isMap()) {
      if (sourceType.getElementType().equals(String.class)) {
        return new StringArrayToMap(sourceType,targetType,this);
      }
 else {
        return null;
      }
    }
 else {
      if (sourceType.getElementType().equals(String.class)) {
        return new StringArrayToObject(targetType,this);
      }
 else {
        return null;
      }
    }
  }
  if (sourceType.isCollection()) {
    if (targetType.isCollection()) {
      return new CollectionToCollection(sourceType,targetType,this);
    }
 else     if (targetType.isArray()) {
      return new CollectionToArray(sourceType,targetType,this);
    }
 else     if (targetType.isMap()) {
      if (sourceType.getElementType().equals(String.class)) {
        return new StringCollectionToMap(sourceType,targetType,this);
      }
 else {
        return null;
      }
    }
 else {
      if (targetType.getType().equals(String.class)) {
        return null;
      }
 else {
        return null;
      }
    }
  }
  if (sourceType.isMap()) {
    if (targetType.isMap()) {
      return new MapToMap(sourceType,targetType,this);
    }
 else     if (targetType.isArray()) {
      if (targetType.getElementType().equals(String.class)) {
        return new MapToStringArray(targetType,this);
      }
 else {
        return null;
      }
    }
 else     if (targetType.isCollection()) {
      if (targetType.getElementType().equals(String.class)) {
        return new MapToStringCollection(targetType,this);
      }
 else {
        return null;
      }
    }
 else {
      return null;
    }
  }
  if (targetType.isArray()) {
    if (sourceType.getType().equals(String.class)) {
      return new StringToArray(targetType,this);
    }
 else {
      return new ObjectToArray(sourceType,targetType,this);
    }
  }
  if (targetType.isCollection()) {
    if (sourceType.getType().equals(String.class)) {
      return new StringToCollection(sourceType,targetType,this);
    }
 else {
      return new ObjectToCollection(sourceType,targetType,this);
    }
  }
  if (targetType.isMap()) {
    if (sourceType.getType().equals(String.class)) {
      return new StringToMap(sourceType,targetType,this);
    }
 else {
      return null;
    }
  }
  if (sourceType.isAssignableTo(targetType)) {
    return NoOpConversionExecutor.INSTANCE;
  }
  Converter converter=findRegisteredConverter(ClassUtils.resolvePrimitiveIfNecessary(sourceClass),ClassUtils.resolvePrimitiveIfNecessary(targetType.getType()));
  if (converter != null) {
    return new StaticConversionExecutor(sourceType,targetType,converter);
  }
 else   if (this.parent instanceof GenericConversionService) {
    return ((GenericConversionService)this.parent).getConversionExecutor(sourceClass,targetType);
  }
 else   if (this.parent != null && this.parent.canConvert(sourceClass,targetType)) {
    return new ConversionExecutor(){
      public Object execute(      Object source){
        return parent.convert(source,targetType);
      }
    }
;
  }
 else {
    return null;
  }
}
