{
  Assert.notNull(sourceClass,"The sourceType to convert from is required");
  Assert.notNull(targetType,"The targetType to convert to is required");
  if (targetType.getType() == null) {
    return NoOpConversionExecutor.INSTANCE;
  }
  TypeDescriptor sourceType=TypeDescriptor.valueOf(sourceClass);
  if (sourceType.isArray()) {
    if (targetType.isArray()) {
      return new ArrayToArray(sourceType,targetType,this);
    }
 else     if (targetType.isCollection()) {
      if (targetType.isAbstractClass()) {
        throw new IllegalArgumentException("Conversion target class [" + targetType.getName() + "] is invalid; cannot convert to abstract collection types--"+ "request an interface or concrete implementation instead");
      }
      return new ArrayToCollection(sourceType,targetType,this);
    }
 else     if (targetType.isMap()) {
      if (sourceType.getElementType().equals(String.class)) {
        return new StringArrayToMap(sourceType,targetType,this);
      }
 else {
        return null;
      }
    }
 else {
      if (targetType.getType().equals(String.class)) {
        return null;
      }
 else {
        return null;
      }
    }
  }
  if (sourceType.isCollection()) {
    if (targetType.isCollection()) {
      return new CollectionToCollection(sourceType,targetType,this);
    }
 else     if (targetType.isArray()) {
      return new CollectionToArray(sourceType,targetType,this);
    }
 else     if (targetType.isMap()) {
      if (sourceType.getElementType().equals(String.class)) {
        return new StringCollectionToMap(sourceType,targetType,this);
      }
 else {
        return null;
      }
    }
 else {
      if (targetType.getType().equals(String.class)) {
        return null;
      }
 else {
        return null;
      }
    }
  }
  if (sourceType.isMap()) {
    if (targetType.isMap()) {
      return new MapToMap(sourceType,targetType,this);
    }
 else     if (targetType.isArray()) {
      if (targetType.getElementType().equals(String.class)) {
        return new MapToStringArray(targetType,this);
      }
 else {
        return null;
      }
    }
 else     if (targetType.isCollection()) {
      if (targetType.getElementType().equals(String.class)) {
        return new MapToStringCollection(targetType,this);
      }
 else {
        return null;
      }
    }
 else {
      return null;
    }
  }
  if (targetType.isArray()) {
    if (sourceType.getType().equals(String.class)) {
      return new StringToArray(sourceType,targetType,this);
    }
 else {
      return new ObjectToArray(sourceType,targetType,this);
    }
  }
  if (targetType.isCollection()) {
    if (sourceType.getType().equals(String.class)) {
      return new StringToCollection(sourceType,targetType,this);
    }
 else {
      return new ObjectToCollection(sourceType,targetType,this);
    }
  }
  if (targetType.isMap()) {
    if (sourceType.getType().equals(String.class)) {
      return new StringToMap(sourceType,targetType,this);
    }
 else {
      return null;
    }
  }
  if (sourceType.isAssignableTo(targetType)) {
    return NoOpConversionExecutor.INSTANCE;
  }
  Converter converter=findRegisteredConverter(sourceType.getType(),targetType.getType());
  if (converter != null) {
    return new StaticConversionExecutor(sourceType,targetType,converter);
  }
 else {
    return null;
  }
}
