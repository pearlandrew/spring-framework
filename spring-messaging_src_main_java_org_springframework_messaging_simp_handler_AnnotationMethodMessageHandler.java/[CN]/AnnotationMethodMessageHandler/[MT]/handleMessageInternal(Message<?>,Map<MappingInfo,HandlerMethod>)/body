{
  if (logger.isTraceEnabled()) {
    logger.trace("Message " + message);
  }
  SimpMessageHeaderAccessor headers=SimpMessageHeaderAccessor.wrap(message);
  String destinationToMatch=getDestinationToMatch(headers.getDestination());
  if (destinationToMatch == null) {
    if (logger.isTraceEnabled()) {
      logger.trace("Ignoring message with destination=" + headers.getDestination());
    }
    return;
  }
  Match match=getMatchingHandlerMethod(destinationToMatch,handlerMethods);
  if (match == null) {
    if (logger.isTraceEnabled()) {
      logger.trace("No matching handler method for destination=" + destinationToMatch);
    }
    return;
  }
  String matchedPattern=match.getMatchedPattern();
  HandlerMethod handlerMethod=match.getHandlerMethod().createWithResolvedBean();
  InvocableHandlerMethod invocableHandlerMethod=new InvocableHandlerMethod(handlerMethod);
  invocableHandlerMethod.setMessageMethodArgumentResolvers(this.argumentResolvers);
  try {
    headers.setDestination(destinationToMatch);
    headers.setHeader(BEST_MATCHING_PATTERN_HEADER,matchedPattern);
    Map<String,String> vars=this.pathMatcher.extractUriTemplateVariables(matchedPattern,destinationToMatch);
    headers.setHeader(PATH_TEMPLATE_VARIABLES_HEADER,vars);
    message=MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build();
    Object returnValue=invocableHandlerMethod.invoke(message);
    MethodParameter returnType=handlerMethod.getReturnType();
    if (void.class.equals(returnType.getParameterType())) {
      return;
    }
    this.returnValueHandlers.handleReturnValue(returnValue,returnType,message);
  }
 catch (  Exception ex) {
    invokeExceptionHandler(message,handlerMethod,ex);
  }
catch (  Throwable ex) {
    logger.error("Error while processing message " + message,ex);
  }
}
