{
  if (logger.isTraceEnabled()) {
    logger.trace("Message " + message);
  }
  SimpMessageHeaderAccessor headers=SimpMessageHeaderAccessor.wrap(message);
  String lookupPath=getLookupPath(headers.getDestination());
  if (lookupPath == null) {
    if (logger.isTraceEnabled()) {
      logger.trace("Ignoring message with destination " + headers.getDestination());
    }
    return;
  }
  MappingInfoMatch match=matchMappingInfo(lookupPath,handlerMethods);
  if (match == null) {
    if (logger.isTraceEnabled()) {
      logger.trace("No matching method, lookup path " + lookupPath);
    }
    return;
  }
  HandlerMethod handlerMethod=match.handlerMethod.createWithResolvedBean();
  InvocableHandlerMethod invocableHandlerMethod=new InvocableHandlerMethod(handlerMethod);
  invocableHandlerMethod.setMessageMethodArgumentResolvers(this.argumentResolvers);
  try {
    headers.setDestination(lookupPath);
    headers.setHeader(BEST_MATCHING_PATTERN_HEADER,match.mappingDestination);
    headers.setHeader(PATH_TEMPLATE_VARIABLES_HEADER,pathMatcher.extractUriTemplateVariables(match.mappingDestination,lookupPath));
    message=MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build();
    Object returnValue=invocableHandlerMethod.invoke(message);
    MethodParameter returnType=handlerMethod.getReturnType();
    if (void.class.equals(returnType.getParameterType())) {
      return;
    }
    this.returnValueHandlers.handleReturnValue(returnValue,returnType,message);
  }
 catch (  Exception ex) {
    invokeExceptionHandler(message,handlerMethod,ex);
  }
catch (  Throwable ex) {
    logger.error("Error while processing message " + message,ex);
  }
}
