{
  LinkedList<InjectionMetadata.InjectedElement> elements=new LinkedList<InjectionMetadata.InjectedElement>();
  Class<?> targetClass=clazz;
  do {
    LinkedList<InjectionMetadata.InjectedElement> currElements=new LinkedList<InjectionMetadata.InjectedElement>();
    for (    Field field : targetClass.getDeclaredFields()) {
      if (field.isAnnotationPresent(PersistenceContext.class) || field.isAnnotationPresent(PersistenceUnit.class)) {
        if (Modifier.isStatic(field.getModifiers())) {
          throw new IllegalStateException("Persistence annotations are not supported on static fields");
        }
        currElements.add(new PersistenceElement(field,field,null));
      }
    }
    for (    Method method : targetClass.getDeclaredMethods()) {
      Method bridgedMethod=BridgeMethodResolver.findBridgedMethod(method);
      if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method,bridgedMethod)) {
        continue;
      }
      if ((bridgedMethod.isAnnotationPresent(PersistenceContext.class) || bridgedMethod.isAnnotationPresent(PersistenceUnit.class)) && method.equals(ClassUtils.getMostSpecificMethod(method,clazz))) {
        if (Modifier.isStatic(method.getModifiers())) {
          throw new IllegalStateException("Persistence annotations are not supported on static methods");
        }
        if (method.getParameterTypes().length != 1) {
          throw new IllegalStateException("Persistence annotation requires a single-arg method: " + method);
        }
        PropertyDescriptor pd=BeanUtils.findPropertyForMethod(bridgedMethod,clazz);
        currElements.add(new PersistenceElement(method,bridgedMethod,pd));
      }
    }
    elements.addAll(0,currElements);
    targetClass=targetClass.getSuperclass();
  }
 while (targetClass != null && targetClass != Object.class);
  return new InjectionMetadata(clazz,elements);
}
