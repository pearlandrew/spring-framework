{
  Assert.state(stomp instanceof String || stomp instanceof byte[],"'stomp' must be String or byte[]");
  byte[] stompBytes=null;
  if (stomp instanceof String) {
    stompBytes=((String)stomp).getBytes(StompMessage.CHARSET);
  }
 else {
    stompBytes=(byte[])stomp;
  }
  int totalLength=stompBytes.length;
  if (stompBytes[totalLength - 1] == 0) {
    totalLength--;
  }
  int payloadIndex=findPayloadStart(stompBytes);
  if (payloadIndex == 0) {
    throw new StompException("No command found");
  }
  String headerString=new String(stompBytes,0,payloadIndex,StompMessage.CHARSET);
  Parser parser=new Parser(headerString);
  StompHeaders headers=new StompHeaders();
  StompCommand command=StompCommand.valueOf(parser.nextToken(LF).trim());
  Assert.notNull(command,"No command found");
  while (parser.hasNext()) {
    String header=parser.nextToken(COLON);
    if (header != null) {
      if (parser.hasNext()) {
        String value=parser.nextToken(LF);
        headers.add(header,value);
      }
 else {
        throw new StompException("Parse exception for " + headerString);
      }
    }
  }
  byte[] payload=new byte[totalLength - payloadIndex];
  System.arraycopy(stompBytes,payloadIndex,payload,0,totalLength - payloadIndex);
  return new StompMessage(command,headers,payload);
}
