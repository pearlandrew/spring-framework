{
  final ConnectionFactory connectionFactory=createMock(ConnectionFactory.class);
  Connection connection=createMock(Connection.class);
  Interaction interaction=createMock(Interaction.class);
  LocalTransaction localTransaction=createMock(LocalTransaction.class);
  final Record record=createMock(Record.class);
  final InteractionSpec interactionSpec=createMock(InteractionSpec.class);
  expect(connectionFactory.getConnection()).andReturn(connection);
  expect(connection.getLocalTransaction()).andReturn(localTransaction);
  localTransaction.begin();
  expect(connection.createInteraction()).andReturn(interaction);
  expect(interaction.execute(interactionSpec,record,record)).andReturn(true);
  interaction.close();
  expect(connection.getLocalTransaction()).andReturn(localTransaction);
  localTransaction.rollback();
  connection.close();
  replay(connectionFactory,connection,localTransaction,interaction,record);
  org.springframework.jca.cci.connection.CciLocalTransactionManager tm=new org.springframework.jca.cci.connection.CciLocalTransactionManager();
  tm.setConnectionFactory(connectionFactory);
  TransactionTemplate tt=new TransactionTemplate(tm);
  try {
    tt.execute(new TransactionCallback(){
      public Object doInTransaction(      TransactionStatus status){
        assertTrue("Has thread connection",TransactionSynchronizationManager.hasResource(connectionFactory));
        CciTemplate ct=new CciTemplate(connectionFactory);
        ct.execute(interactionSpec,record,record);
        throw new DataRetrievalFailureException("error");
      }
    }
);
  }
 catch (  Exception ex) {
  }
  verify(connectionFactory,connection,localTransaction,interaction,record);
}
