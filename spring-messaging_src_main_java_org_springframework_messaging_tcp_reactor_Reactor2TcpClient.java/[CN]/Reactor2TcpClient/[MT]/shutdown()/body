{
  final List<TcpClient<Message<P>,Message<P>>> clients;
synchronized (activeClients) {
    clients=new ArrayList<TcpClient<Message<P>,Message<P>>>(activeClients);
  }
  Promise<Boolean> promise=Streams.from(clients).flatMap(new Function<TcpClient<Message<P>,Message<P>>,Promise<Boolean>>(){
    @Override public Promise<Boolean> apply(    TcpClient<Message<P>,Message<P>> client){
      return client.close();
    }
  }
).reduce(new BiFunction<Boolean,Boolean,Boolean>(){
    @Override public Boolean apply(    Boolean prev,    Boolean next){
      return prev && next;
    }
  }
).next();
  return new AbstractPromiseToListenableFutureAdapter<Boolean,Boolean>(promise){
    @Override protected Boolean adapt(    Boolean result){
      return result;
    }
  }
;
}
