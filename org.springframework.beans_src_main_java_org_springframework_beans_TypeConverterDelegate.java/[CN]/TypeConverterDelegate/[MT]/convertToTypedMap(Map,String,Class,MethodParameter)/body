{
  boolean originalAllowed=requiredType.isInstance(original);
  Class keyType=null;
  Class valueType=null;
  if (methodParam != null) {
    keyType=GenericCollectionTypeResolver.getMapKeyParameterType(methodParam);
    valueType=GenericCollectionTypeResolver.getMapValueParameterType(methodParam);
  }
  if (keyType == null && valueType == null && originalAllowed && !this.propertyEditorRegistry.hasCustomEditorForElement(null,propertyName)) {
    return original;
  }
  Iterator it;
  try {
    it=original.entrySet().iterator();
    if (it == null) {
      if (logger.isDebugEnabled()) {
        logger.debug("Map of type [" + original.getClass().getName() + "] returned null Iterator - injecting original Map as-is");
      }
      return original;
    }
  }
 catch (  Throwable ex) {
    if (logger.isDebugEnabled()) {
      logger.debug("Cannot access Map of type [" + original.getClass().getName() + "] - injecting original Map as-is",ex);
    }
    return original;
  }
  Map convertedCopy;
  try {
    if (CollectionFactory.isApproximableMapType(requiredType)) {
      convertedCopy=CollectionFactory.createApproximateMap(original,original.size());
    }
 else {
      convertedCopy=(Map)requiredType.newInstance();
    }
  }
 catch (  Throwable ex) {
    if (logger.isDebugEnabled()) {
      logger.debug("Cannot create copy of Map type [" + original.getClass().getName() + "] - injecting original Map as-is",ex);
    }
    return original;
  }
  while (it.hasNext()) {
    Map.Entry entry=(Map.Entry)it.next();
    Object key=entry.getKey();
    Object value=entry.getValue();
    String keyedPropertyName=buildKeyedPropertyName(propertyName,key);
    if (methodParam != null) {
      methodParam.increaseNestingLevel();
      methodParam.setTypeIndexForCurrentLevel(0);
    }
    Object convertedKey=convertIfNecessary(keyedPropertyName,null,key,keyType,null,methodParam);
    if (methodParam != null) {
      methodParam.setTypeIndexForCurrentLevel(1);
    }
    Object convertedValue=convertIfNecessary(keyedPropertyName,null,value,valueType,null,methodParam);
    if (methodParam != null) {
      methodParam.decreaseNestingLevel();
    }
    convertedCopy.put(convertedKey,convertedValue);
    originalAllowed=originalAllowed && (key == convertedKey) && (value == convertedValue);
  }
  return (originalAllowed ? original : convertedCopy);
}
