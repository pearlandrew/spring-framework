{
  List<Message<byte[]>> messages=null;
  try {
    Assert.isInstanceOf(TextMessage.class,webSocketMessage);
    TextMessage textMessage=(TextMessage)webSocketMessage;
    ByteBuffer byteBuffer=ByteBuffer.wrap(textMessage.asBytes());
    BufferingStompDecoder decoder=this.decoders.get(session.getId());
    if (decoder == null) {
      throw new IllegalStateException("No decoder for session id '" + session.getId() + "'");
    }
    messages=decoder.decode(byteBuffer);
    if (messages.isEmpty()) {
      logger.debug("Incomplete STOMP frame content received," + "buffered=" + decoder.getBufferSize() + ", buffer size limit="+ decoder.getBufferSizeLimit());
      return;
    }
  }
 catch (  Throwable ex) {
    logger.error("Failed to parse WebSocket message to STOMP frame(s)",ex);
    sendErrorMessage(session,ex);
    return;
  }
  for (  Message<byte[]> message : messages) {
    try {
      StompHeaderAccessor headerAccessor=MessageHeaderAccessor.getAccessor(message,StompHeaderAccessor.class);
      if (logger.isTraceEnabled()) {
        if (headerAccessor.isHeartbeat()) {
          logger.trace("Received heartbeat from client session=" + session.getId());
        }
 else {
          logger.trace("Received message from client session=" + session.getId());
        }
      }
      headerAccessor.setSessionId(session.getId());
      headerAccessor.setSessionAttributes(session.getAttributes());
      headerAccessor.setUser(session.getPrincipal());
      headerAccessor.setImmutable();
      if (this.eventPublisher != null && StompCommand.CONNECT.equals(headerAccessor.getCommand())) {
        publishEvent(new SessionConnectEvent(this,message));
      }
      outputChannel.send(message);
    }
 catch (    Throwable ex) {
      logger.error("Terminating STOMP session due to failure to send message",ex);
      sendErrorMessage(session,ex);
    }
  }
}
