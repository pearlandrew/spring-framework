{
  if (!(message.getPayload() instanceof byte[])) {
    logger.error("Expected byte[] payload. Ignoring " + message + ".");
    return;
  }
  StompHeaderAccessor stompAccessor=getStompHeaderAccessor(message);
  StompCommand command=stompAccessor.getCommand();
  if (StompCommand.MESSAGE.equals(command)) {
    if (stompAccessor.getSubscriptionId() == null) {
      logger.warn("No STOMP \"subscription\" header in " + message);
    }
    String origDestination=stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);
    if (origDestination != null) {
      stompAccessor=toMutableAccessor(stompAccessor,message);
      stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);
      stompAccessor.setDestination(origDestination);
    }
  }
 else   if (StompCommand.CONNECTED.equals(command)) {
    this.stats.incrementConnectedCount();
    stompAccessor=afterStompSessionConnected(message,stompAccessor,session);
    if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {
      try {
        SimpAttributes simpAttributes=new SimpAttributes(session.getId(),session.getAttributes());
        SimpAttributesContextHolder.setAttributes(simpAttributes);
        Principal user=session.getPrincipal();
        publishEvent(new SessionConnectedEvent(this,(Message<byte[]>)message,user));
      }
  finally {
        SimpAttributesContextHolder.resetAttributes();
      }
    }
  }
  try {
    byte[] payload=(byte[])message.getPayload();
    byte[] bytes=this.stompEncoder.encode(stompAccessor.getMessageHeaders(),payload);
    boolean useBinary=(payload.length > 0 && !(session instanceof SockJsSession) && MimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(stompAccessor.getContentType()));
    if (useBinary) {
      session.sendMessage(new BinaryMessage(bytes));
    }
 else {
      session.sendMessage(new TextMessage(bytes));
    }
  }
 catch (  SessionLimitExceededException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    logger.debug("Failed to send WebSocket message to client in session " + session.getId() + ".",ex);
    command=StompCommand.ERROR;
  }
 finally {
    if (StompCommand.ERROR.equals(command)) {
      try {
        session.close(CloseStatus.PROTOCOL_ERROR);
      }
 catch (      IOException ex) {
      }
    }
  }
}
