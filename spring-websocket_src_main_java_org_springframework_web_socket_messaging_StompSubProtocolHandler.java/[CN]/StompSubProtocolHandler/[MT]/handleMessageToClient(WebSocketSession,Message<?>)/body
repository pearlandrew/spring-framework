{
  if (!(message.getPayload() instanceof byte[])) {
    logger.error("Expected byte[] payload. Ignoring " + message + ".");
    return;
  }
  StompHeaderAccessor stompAccessor=getStompHeaderAccessor(message);
  StompCommand command=stompAccessor.getCommand();
  if (StompCommand.MESSAGE.equals(command)) {
    if (stompAccessor.getSubscriptionId() == null) {
      if (logger.isWarnEnabled()) {
        logger.warn("No STOMP \"subscription\" header in " + message);
      }
    }
    String origDestination=stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);
    if (origDestination != null) {
      stompAccessor=toMutableAccessor(stompAccessor,message);
      stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);
      stompAccessor.setDestination(origDestination);
    }
  }
 else   if (StompCommand.CONNECTED.equals(command)) {
    stompAccessor=afterStompSessionConnected(message,stompAccessor,session);
    if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {
      publishEvent(new SessionConnectedEvent(this,(Message<byte[]>)message));
    }
  }
  try {
    byte[] bytes=this.stompEncoder.encode(stompAccessor.getMessageHeaders(),(byte[])message.getPayload());
    session.sendMessage(new TextMessage(bytes));
  }
 catch (  SessionLimitExceededException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    logger.error("Failed to send WebSocket message to client in session " + session.getId() + ".",ex);
    command=StompCommand.ERROR;
  }
 finally {
    if (StompCommand.ERROR.equals(command)) {
      try {
        session.close(CloseStatus.PROTOCOL_ERROR);
      }
 catch (      IOException ex) {
      }
    }
  }
}
