{
  StompHeaderAccessor headers=StompHeaderAccessor.wrap(message);
  if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {
    StompHeaderAccessor connectedHeaders=StompHeaderAccessor.create(StompCommand.CONNECTED);
    connectedHeaders.setVersion(getVersion(headers));
    connectedHeaders.setHeartbeat(0,0);
    headers=connectedHeaders;
  }
 else   if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {
    headers.updateStompCommandAsServerMessage();
  }
  if (headers.getCommand() == StompCommand.CONNECTED) {
    afterStompSessionConnected(headers,session);
  }
  if (StompCommand.MESSAGE.equals(headers.getCommand()) && (headers.getSubscriptionId() == null)) {
    logger.error("Ignoring message, no subscriptionId header: " + message);
    return;
  }
  if (!(message.getPayload() instanceof byte[])) {
    logger.error("Ignoring message, expected byte[] content: " + message);
    return;
  }
  try {
    message=MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build();
    byte[] bytes=this.stompEncoder.encode((Message<byte[]>)message);
synchronized (session) {
      session.sendMessage(new TextMessage(new String(bytes,Charset.forName("UTF-8"))));
    }
  }
 catch (  Throwable t) {
    sendErrorMessage(session,t);
  }
 finally {
    if (StompCommand.ERROR.equals(headers.getCommand())) {
      try {
        session.close(CloseStatus.PROTOCOL_ERROR);
      }
 catch (      IOException e) {
      }
    }
  }
}
