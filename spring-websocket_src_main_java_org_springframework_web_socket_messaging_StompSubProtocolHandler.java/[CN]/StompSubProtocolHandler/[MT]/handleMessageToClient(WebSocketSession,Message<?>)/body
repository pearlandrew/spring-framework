{
  if (!(message.getPayload() instanceof byte[])) {
    logger.error("Ignoring message, expected byte[] content: " + message);
    return;
  }
  MessageHeaderAccessor accessor=MessageHeaderAccessor.getAccessor(message,MessageHeaderAccessor.class);
  if (accessor == null) {
    logger.error("No header accessor: " + message);
    return;
  }
  StompHeaderAccessor stompAccessor;
  if (accessor instanceof StompHeaderAccessor) {
    stompAccessor=(StompHeaderAccessor)accessor;
  }
 else   if (accessor instanceof SimpMessageHeaderAccessor) {
    stompAccessor=StompHeaderAccessor.wrap(message);
    if (SimpMessageType.CONNECT_ACK.equals(stompAccessor.getMessageType())) {
      StompHeaderAccessor connectedHeaders=StompHeaderAccessor.create(StompCommand.CONNECTED);
      connectedHeaders.setVersion(getVersion(stompAccessor));
      connectedHeaders.setHeartbeat(0,0);
      stompAccessor=connectedHeaders;
    }
 else     if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {
      stompAccessor.updateStompCommandAsServerMessage();
    }
  }
 else {
    logger.error("Unexpected header accessor type: " + accessor);
    return;
  }
  StompCommand command=stompAccessor.getCommand();
  if (StompCommand.MESSAGE.equals(command)) {
    if (stompAccessor.getSubscriptionId() == null) {
      logger.error("Ignoring message, no subscriptionId header: " + message);
      return;
    }
    String origDestination=stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);
    if (origDestination != null) {
      stompAccessor=toMutableAccessor(stompAccessor,message);
      stompAccessor.setDestination(origDestination);
    }
  }
 else   if (StompCommand.CONNECTED.equals(command)) {
    stompAccessor=afterStompSessionConnected(message,stompAccessor,session);
    if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {
      publishEvent(new SessionConnectedEvent(this,(Message<byte[]>)message));
    }
  }
  try {
    byte[] bytes=this.stompEncoder.encode(stompAccessor.getMessageHeaders(),(byte[])message.getPayload());
    TextMessage textMessage=new TextMessage(bytes);
    session.sendMessage(textMessage);
  }
 catch (  SessionLimitExceededException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    sendErrorMessage(session,ex);
  }
 finally {
    if (StompCommand.ERROR.equals(command)) {
      try {
        session.close(CloseStatus.PROTOCOL_ERROR);
      }
 catch (      IOException ex) {
      }
    }
  }
}
