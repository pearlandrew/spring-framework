{
  if (!(message.getPayload() instanceof byte[])) {
    logger.error("Expected byte[] payload. Ignoring " + message + ".");
    return;
  }
  StompHeaderAccessor stompAccessor=getStompHeaderAccessor(message);
  StompCommand command=stompAccessor.getCommand();
  if (StompCommand.MESSAGE.equals(command)) {
    if (stompAccessor.getSubscriptionId() == null) {
      logger.warn("No STOMP \"subscription\" header in " + message);
    }
    String origDestination=stompAccessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);
    if (origDestination != null) {
      stompAccessor=toMutableAccessor(stompAccessor,message);
      stompAccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);
      stompAccessor.setDestination(origDestination);
    }
  }
 else   if (StompCommand.CONNECTED.equals(command)) {
    this.stats.incrementConnectedCount();
    stompAccessor=afterStompSessionConnected(message,stompAccessor,session);
    if (this.eventPublisher != null && StompCommand.CONNECTED.equals(command)) {
      try {
        SimpAttributes simpAttributes=new SimpAttributes(session.getId(),session.getAttributes());
        SimpAttributesContextHolder.setAttributes(simpAttributes);
        Principal user=session.getPrincipal();
        publishEvent(new SessionConnectedEvent(this,(Message<byte[]>)message,user));
      }
  finally {
        SimpAttributesContextHolder.resetAttributes();
      }
    }
  }
  byte[] payload=(byte[])message.getPayload();
  if (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {
    Message<byte[]> errorMessage=getErrorHandler().handleErrorMessageToClient((Message<byte[]>)message);
    stompAccessor=MessageHeaderAccessor.getAccessor(errorMessage,StompHeaderAccessor.class);
    Assert.notNull(stompAccessor,"Expected STOMP headers.");
    payload=errorMessage.getPayload();
  }
  sendToClient(session,stompAccessor,payload);
}
