{
  StompHeaderAccessor headers=StompHeaderAccessor.wrap(message);
  if (headers.getMessageType() == SimpMessageType.CONNECT_ACK) {
    StompHeaderAccessor connectedHeaders=StompHeaderAccessor.create(StompCommand.CONNECTED);
    connectedHeaders.setVersion(getVersion(headers));
    connectedHeaders.setHeartbeat(0,0);
    headers=connectedHeaders;
  }
 else   if (SimpMessageType.MESSAGE.equals(headers.getMessageType())) {
    headers.updateStompCommandAsServerMessage();
  }
  if (headers.getCommand() == StompCommand.CONNECTED) {
    afterStompSessionConnected(headers,session);
  }
  if (StompCommand.MESSAGE.equals(headers.getCommand())) {
    if (headers.getSubscriptionId() == null) {
      logger.error("Ignoring message, no subscriptionId header: " + message);
      return;
    }
    String header=UserDestinationMessageHandler.SUBSCRIBE_DESTINATION;
    if (message.getHeaders().containsKey(header)) {
      headers.setDestination((String)message.getHeaders().get(header));
    }
  }
  if (!(message.getPayload() instanceof byte[])) {
    logger.error("Ignoring message, expected byte[] content: " + message);
    return;
  }
  try {
    message=MessageBuilder.withPayload(message.getPayload()).setHeaders(headers).build();
    if (headers.getCommand() == StompCommand.CONNECTED && this.eventPublisher != null) {
      this.eventPublisher.publishEvent(new SessionConnectedEvent(this,(Message<byte[]>)message));
    }
    byte[] bytes=this.stompEncoder.encode((Message<byte[]>)message);
    TextMessage textMessage=new TextMessage(bytes);
    session.sendMessage(textMessage);
  }
 catch (  SessionLimitExceededException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    sendErrorMessage(session,ex);
  }
 finally {
    if (StompCommand.ERROR.equals(headers.getCommand())) {
      try {
        session.close(CloseStatus.PROTOCOL_ERROR);
      }
 catch (      IOException ex) {
      }
    }
  }
}
