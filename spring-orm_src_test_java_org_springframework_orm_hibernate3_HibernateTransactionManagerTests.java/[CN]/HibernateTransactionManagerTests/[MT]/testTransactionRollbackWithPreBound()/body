{
  final DataSource ds=mock(DataSource.class);
  Connection con=mock(Connection.class);
  final SessionFactory sf=mock(SessionFactory.class);
  final Session session=mock(Session.class);
  final Transaction tx1=mock(Transaction.class);
  final Transaction tx2=mock(Transaction.class);
  given(session.beginTransaction()).willReturn(tx1,tx2);
  given(session.isOpen()).willReturn(true);
  given(session.getFlushMode()).willReturn(FlushMode.MANUAL);
  given(session.isConnected()).willReturn(true);
  given(session.connection()).willReturn(con);
  HibernateTransactionManager tm=new HibernateTransactionManager();
  tm.setSessionFactory(sf);
  tm.setDataSource(ds);
  final TransactionTemplate tt=new TransactionTemplate(tm);
  assertTrue("Hasn't thread connection",!TransactionSynchronizationManager.hasResource(ds));
  assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
  TransactionSynchronizationManager.bindResource(sf,new SessionHolder(session));
  assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
  try {
    tt.execute(new TransactionCallbackWithoutResult(){
      @Override public void doInTransactionWithoutResult(      TransactionStatus status){
        assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
        assertTrue("Has thread connection",TransactionSynchronizationManager.hasResource(ds));
        SessionHolder sessionHolder=(SessionHolder)TransactionSynchronizationManager.getResource(sf);
        assertEquals(tx1,sessionHolder.getTransaction());
        tt.execute(new TransactionCallbackWithoutResult(){
          @Override public void doInTransactionWithoutResult(          TransactionStatus status){
            status.setRollbackOnly();
            HibernateTemplate ht=new HibernateTemplate(sf);
            ht.setExposeNativeSession(true);
            ht.execute(new HibernateCallback(){
              @Override public Object doInHibernate(              org.hibernate.Session sess) throws HibernateException {
                assertEquals(session,sess);
                return null;
              }
            }
);
          }
        }
);
      }
    }
);
    fail("Should have thrown UnexpectedRollbackException");
  }
 catch (  UnexpectedRollbackException ex) {
  }
  assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
  SessionHolder sessionHolder=(SessionHolder)TransactionSynchronizationManager.getResource(sf);
  assertTrue("Hasn't thread transaction",sessionHolder.getTransaction() == null);
  assertTrue("Not marked rollback-only",!sessionHolder.isRollbackOnly());
  tt.execute(new TransactionCallbackWithoutResult(){
    @Override public void doInTransactionWithoutResult(    TransactionStatus status){
      assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
      assertTrue("Has thread connection",TransactionSynchronizationManager.hasResource(ds));
      SessionHolder sessionHolder=(SessionHolder)TransactionSynchronizationManager.getResource(sf);
      assertEquals(tx2,sessionHolder.getTransaction());
      HibernateTemplate ht=new HibernateTemplate(sf);
      ht.setExposeNativeSession(true);
      ht.execute(new HibernateCallback(){
        @Override public Object doInHibernate(        org.hibernate.Session sess) throws HibernateException {
          assertEquals(session,sess);
          return null;
        }
      }
);
    }
  }
);
  assertTrue("Has thread session",TransactionSynchronizationManager.hasResource(sf));
  assertTrue("Hasn't thread transaction",sessionHolder.getTransaction() == null);
  TransactionSynchronizationManager.unbindResource(sf);
  assertTrue("Hasn't thread connection",!TransactionSynchronizationManager.hasResource(ds));
  assertTrue("JTA synchronizations not active",!TransactionSynchronizationManager.isSynchronizationActive());
  verify(tx1).rollback();
  verify(tx2).commit();
  InOrder ordered=inOrder(session);
  ordered.verify(session).clear();
  ordered.verify(session).setFlushMode(FlushMode.AUTO);
  ordered.verify(session).setFlushMode(FlushMode.MANUAL);
  ordered.verify(session).disconnect();
}
