{
  try {
    Assert.isTrue(void.class.equals(method.getReturnType()),"Only void-returning methods may be annotated with @Scheduled");
    Assert.isTrue(method.getParameterTypes().length == 0,"Only no-arg methods may be annotated with @Scheduled");
    if (AopUtils.isJdkDynamicProxy(bean)) {
      try {
        method=bean.getClass().getMethod(method.getName(),method.getParameterTypes());
      }
 catch (      SecurityException ex) {
        ReflectionUtils.handleReflectionException(ex);
      }
catch (      NoSuchMethodException ex) {
        throw new IllegalStateException(String.format("@Scheduled method '%s' found on bean target class '%s' but not " + "found in any interface(s) for a dynamic proxy. Either pull the " + "method up to a declared interface or switch to subclass (CGLIB) "+ "proxies by setting proxy-target-class/proxyTargetClass to 'true'",method.getName(),method.getDeclaringClass().getSimpleName()));
      }
    }
 else     if (AopUtils.isCglibProxy(bean)) {
      if (Modifier.isPrivate(method.getModifiers())) {
        throw new IllegalStateException(String.format("@Scheduled method '%s' found on CGLIB proxy for target class '%s' but cannot " + "be delegated to target bean. Switch its visibility to package or protected.",method.getName(),method.getDeclaringClass().getSimpleName()));
      }
    }
    Runnable runnable=new ScheduledMethodRunnable(bean,method);
    boolean processedSchedule=false;
    String errorMessage="Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required";
    long initialDelay=scheduled.initialDelay();
    String initialDelayString=scheduled.initialDelayString();
    if (StringUtils.hasText(initialDelayString)) {
      Assert.isTrue(initialDelay < 0,"Specify 'initialDelay' or 'initialDelayString', not both");
      if (this.embeddedValueResolver != null) {
        initialDelayString=this.embeddedValueResolver.resolveStringValue(initialDelayString);
      }
      try {
        initialDelay=Integer.parseInt(initialDelayString);
      }
 catch (      NumberFormatException ex) {
        throw new IllegalArgumentException("Invalid initialDelayString value \"" + initialDelayString + "\" - cannot parse into integer");
      }
    }
    String cron=scheduled.cron();
    if (StringUtils.hasText(cron)) {
      Assert.isTrue(initialDelay == -1,"'initialDelay' not supported for cron triggers");
      processedSchedule=true;
      String zone=scheduled.zone();
      if (this.embeddedValueResolver != null) {
        cron=this.embeddedValueResolver.resolveStringValue(cron);
        zone=this.embeddedValueResolver.resolveStringValue(zone);
      }
      TimeZone timeZone;
      if (StringUtils.hasText(zone)) {
        timeZone=StringUtils.parseTimeZoneString(zone);
      }
 else {
        timeZone=TimeZone.getDefault();
      }
      this.registrar.addCronTask(new CronTask(runnable,new CronTrigger(cron,timeZone)));
    }
    if (initialDelay < 0) {
      initialDelay=0;
    }
    long fixedDelay=scheduled.fixedDelay();
    if (fixedDelay >= 0) {
      Assert.isTrue(!processedSchedule,errorMessage);
      processedSchedule=true;
      this.registrar.addFixedDelayTask(new IntervalTask(runnable,fixedDelay,initialDelay));
    }
    String fixedDelayString=scheduled.fixedDelayString();
    if (StringUtils.hasText(fixedDelayString)) {
      Assert.isTrue(!processedSchedule,errorMessage);
      processedSchedule=true;
      if (this.embeddedValueResolver != null) {
        fixedDelayString=this.embeddedValueResolver.resolveStringValue(fixedDelayString);
      }
      try {
        fixedDelay=Integer.parseInt(fixedDelayString);
      }
 catch (      NumberFormatException ex) {
        throw new IllegalArgumentException("Invalid fixedDelayString value \"" + fixedDelayString + "\" - cannot parse into integer");
      }
      this.registrar.addFixedDelayTask(new IntervalTask(runnable,fixedDelay,initialDelay));
    }
    long fixedRate=scheduled.fixedRate();
    if (fixedRate >= 0) {
      Assert.isTrue(!processedSchedule,errorMessage);
      processedSchedule=true;
      this.registrar.addFixedRateTask(new IntervalTask(runnable,fixedRate,initialDelay));
    }
    String fixedRateString=scheduled.fixedRateString();
    if (StringUtils.hasText(fixedRateString)) {
      Assert.isTrue(!processedSchedule,errorMessage);
      processedSchedule=true;
      if (this.embeddedValueResolver != null) {
        fixedRateString=this.embeddedValueResolver.resolveStringValue(fixedRateString);
      }
      try {
        fixedRate=Integer.parseInt(fixedRateString);
      }
 catch (      NumberFormatException ex) {
        throw new IllegalArgumentException("Invalid fixedRateString value \"" + fixedRateString + "\" - cannot parse into integer");
      }
      this.registrar.addFixedRateTask(new IntervalTask(runnable,fixedRate,initialDelay));
    }
    Assert.isTrue(processedSchedule,errorMessage);
  }
 catch (  IllegalArgumentException ex) {
    throw new IllegalStateException("Encountered invalid @Scheduled method '" + method.getName() + "': "+ ex.getMessage());
  }
}
