{
  Object value=result.getValue();
  HandlerMethod handlerMethod=(HandlerMethod)result.getHandler();
  MethodParameter returnType=handlerMethod.getReturnValueType(value);
  if (value == null) {
    return Publishers.empty();
  }
  MediaType mediaType=resolveMediaType(request);
  ResolvableType type=ResolvableType.forMethodParameter(returnType);
  List<Object> hints=new ArrayList<>();
  hints.add(UTF_8);
  MessageToByteEncoder<Object> serializer=(MessageToByteEncoder<Object>)resolveSerializer(request,type,mediaType,hints.toArray());
  if (serializer != null) {
    Publisher<Object> elementStream;
    if (Promise.class.isAssignableFrom(type.getRawClass())) {
      elementStream=((Promise)value).stream();
    }
 else     if (Observable.class.isAssignableFrom(type.getRawClass())) {
      elementStream=RxJava1Converter.from((Observable)value);
    }
 else     if (Single.class.isAssignableFrom(type.getRawClass())) {
      elementStream=RxJava1SingleConverter.from((Single)value);
    }
 else     if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {
      elementStream=CompletableFutureConverter.from((CompletableFuture)value);
    }
 else     if (Publisher.class.isAssignableFrom(type.getRawClass())) {
      elementStream=(Publisher)value;
    }
 else {
      elementStream=Publishers.just(value);
    }
    Publisher<ByteBuffer> outputStream=serializer.encode(elementStream,type,mediaType,hints.toArray());
    List<MessageToByteEncoder<ByteBuffer>> postProcessors=resolvePostProcessors(request,type,mediaType,hints.toArray());
    for (    MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {
      outputStream=postProcessor.encode(outputStream,type,mediaType,hints.toArray());
    }
    response.getHeaders().setContentType(mediaType);
    return response.writeWith(outputStream);
  }
  return Publishers.error(new IllegalStateException("Return value type '" + returnType.getParameterType().getName() + "' with media type '"+ mediaType+ "' not supported"));
}
